<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2HP Mini‑Rack – Interactive Patcher</title>
    <style>
        :root {
            --hp-unit: 18px;
            --module-height: 380px;
            --jack-size: 24px;
            --knob-size: 32px;
            --knob-sm: 20px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        .rack {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 0 20px;
            display: flex;
            gap: 4px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
            position: relative;
        }

        .module {
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border: none;
            border-left: 1px solid #111;
            border-radius: 0;
            height: var(--module-height);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            position: relative;
            flex-shrink: 0;
            flex-grow: 0;
        }

        .module:last-child {
            border-right: 1px solid #111;
        }

        .module-2hp { width: calc(var(--hp-unit) * 2); }
        .module-3hp { width: calc(var(--hp-unit) * 3); }
        .module-4hp { width: calc(var(--hp-unit) * 4); }
        .module-6hp { width: calc(var(--hp-unit) * 6); }
        .module-8hp { width: calc(var(--hp-unit) * 8); }

        .module-label {
            font-size: 9px;
            font-weight: bold;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .module-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 100%;
        }

        /* Knobs */
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .knob {
            width: var(--knob-size);
            height: var(--knob-size);
            background: linear-gradient(145deg, #555, #333);
            border-radius: 50%;
            border: 2px solid #222;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.1);
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 10px;
            background: #fff;
            border-radius: 1px;
            top: 4px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
            box-shadow: 0 0 3px rgba(255,255,255,0.5);
        }

        .knob:hover {
            background: linear-gradient(145deg, #666, #444);
        }

        .knob-label {
            font-size: 7px;
            color: #999;
            text-transform: uppercase;
        }

        /* Small trimmer-style potentiometer */
        .knob.knob-sm {
            width: var(--knob-sm);
            height: var(--knob-sm);
            background:
                radial-gradient(circle at 50% 50%, #4a4a4a 0%, #3a3a3a 60%, #2a2a2a 100%);
            border: 1px solid #222;
            box-shadow:
                0 1px 3px rgba(0,0,0,0.5),
                inset 0 1px 1px rgba(255,255,255,0.15),
                inset 0 -1px 1px rgba(0,0,0,0.3);
        }

        /* Thin white line pointer with inset shading */
        .knob.knob-sm::after {
            width: 2px;
            height: 7px;
            background: linear-gradient(to bottom, #fff 0%, #ccc 100%);
            border-radius: 1px;
            top: 3px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
            box-shadow:
                inset 1px 0 0 rgba(255,255,255,0.3),
                inset -1px 0 0 rgba(0,0,0,0.2),
                0 0 2px rgba(0,0,0,0.4);
        }

        .knob.knob-sm:hover {
            background:
                radial-gradient(circle at 50% 50%, #555 0%, #454545 60%, #353535 100%);
        }

        /* Jacks */
        .jack-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .jack {
            width: var(--jack-size);
            height: var(--jack-size);
            background: radial-gradient(circle at 30% 30%, #222, #111);
            border-radius: 50%;
            border: 2px solid #444;
            position: relative;
            cursor: crosshair;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8);
        }

        .jack::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #111;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #333;
        }

        .jack.output {
            border-color: #c44;
        }

        .jack.input {
            border-color: #4a4;
        }

        .jack:hover {
            border-color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8), 0 0 8px rgba(255,255,255,0.3);
        }

        .jack.connected::after {
            background: #666;
        }

        .jack-label {
            font-size: 6px;
            color: #888;
            text-transform: uppercase;
        }

        /* Jack rows */
        .jack-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Compact elements for wider modules */
        .module-8hp .jack-row {
            gap: 2px;
        }

        .module-8hp .jack {
            width: 20px;
            height: 20px;
        }

        .module-8hp .switch {
            width: 14px;
            height: 20px;
        }

        .module-8hp .switch::after {
            width: 10px;
            height: 8px;
            left: 1px;
            top: 2px;
        }

        .module-8hp .switch.on::after {
            top: 9px;
        }

        .module-8hp .knob {
            width: 28px;
            height: 28px;
        }

        .module-8hp .knob::after {
            height: 8px;
            top: 3px;
        }

        /* LEDs */
        .led {
            width: 6px;
            height: 6px;
            background: #300;
            border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        .led.active {
            background: #f44;
            box-shadow: 0 0 8px #f44, inset 0 1px 2px rgba(255,255,255,0.3);
        }

        .led.green { background: #030; }
        .led.green.active { background: #4f4; box-shadow: 0 0 8px #4f4; }

        /* Switches */
        .switch {
            width: 16px;
            height: 24px;
            background: linear-gradient(to bottom, #444, #333);
            border-radius: 3px;
            border: 1px solid #555;
            cursor: pointer;
            position: relative;
        }

        .switch::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 10px;
            background: linear-gradient(to bottom, #888, #666);
            border-radius: 2px;
            left: 1px;
            top: 2px;
            transition: top 0.1s;
        }

        .switch.on::after {
            top: 11px;
        }

        /* Button bank (octave select) */
        .button-bank {
            display: flex;
            gap: 2px;
            padding: 2px 0;
        }

        .octave-btn {
            width: 14px;
            height: 16px;
            font-size: 7px;
            background: linear-gradient(to bottom, #444, #333);
            border: 1px solid #555;
            border-radius: 2px;
            color: #999;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .octave-btn:hover {
            background: linear-gradient(to bottom, #555, #444);
        }

        .octave-btn.active {
            background: linear-gradient(to bottom, #8b5cf6, #6d28d9);
            border-color: #a78bfa;
            color: #fff;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.5);
        }

        /* Toggle buttons (gate on/off) */
        .toggle-row {
            display: flex;
            gap: 2px;
            padding: 2px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .toggle-btn {
            width: 12px;
            height: 12px;
            font-size: 6px;
            background: linear-gradient(to bottom, #333, #222);
            border: 1px solid #444;
            border-radius: 2px;
            color: #666;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-btn:hover {
            background: linear-gradient(to bottom, #444, #333);
        }

        .toggle-btn.active {
            background: linear-gradient(to bottom, #22c55e, #16a34a);
            border-color: #4ade80;
            color: #fff;
            box-shadow: 0 0 4px rgba(34, 197, 94, 0.5);
        }

        /* Cable SVG overlay */
        #cable-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .cable {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
        }

        .cable-preview {
            opacity: 0.6;
            stroke-dasharray: 8 4;
        }

        /* Spacer */
        .spacer {
            flex: 1;
        }

        /* Section dividers */
        .section-label {
            font-size: 6px;
            color: #666;
            width: 100%;
            text-align: center;
            border-top: 1px solid #444;
            padding-top: 4px;
            margin-top: 2px;
        }

        /* Toolbar */
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
            z-index: 200;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: #444;
        }

        .toolbar-spacer {
            flex: 1;
        }

        #toolbar select {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            cursor: pointer;
            min-width: 140px;
        }

        #toolbar select:hover {
            background: #444;
        }

        #toolbar input[type="text"] {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 110px;
        }

        #toolbar input[type="text"]::placeholder {
            color: #666;
        }

        #toolbar button {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #444;
            color: #fff;
            transition: background 0.2s;
            white-space: nowrap;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.primary {
            background: #2a5a2a;
        }

        #toolbar button.primary:hover {
            background: #3a7a3a;
        }

        #toolbar button.danger {
            background: #5a2a2a;
        }

        #toolbar button.danger:hover {
            background: #7a3a3a;
        }

        #toolbar button.active {
            background: #4a4;
        }

        .toolbar-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Offset rack for toolbar */
        .rack {
            margin-top: 48px;
        }

        /* App container - sidebar + rack area */
        .app-container {
            display: flex;
            margin-top: 48px;
            height: calc(100vh - 48px);
        }

        /* Sidebar */
        .sidebar {
            width: 180px;
            min-width: 180px;
            background: linear-gradient(to bottom, #252525, #1a1a1a);
            border-right: 1px solid #444;
            overflow-y: auto;
            padding: 8px 0;
        }

        .sidebar-category {
            padding: 8px 12px 4px;
            font-size: 9px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-module {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .sidebar-module:hover {
            background: #333;
        }

        .sidebar-module-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .sidebar-module-name {
            flex: 1;
            font-size: 11px;
            color: #ccc;
        }

        .sidebar-module-hp {
            font-size: 9px;
            color: #666;
        }

        /* Rack container - holds two rows */
        .rack-container {
            /* Fixed width: 84HP * 18px + rack padding (40px) + container padding (32px) */
            width: calc(84 * var(--hp-unit) + 72px);
            flex-shrink: 0;
            overflow-x: auto;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 16px;
        }

        .rack-row {
            /* Fixed width: 84HP exactly */
            width: calc(84 * var(--hp-unit));
            margin-top: 0;
            height: var(--module-height);
            min-height: var(--module-height);
            flex-shrink: 0;
            display: flex;
            align-items: stretch;
            position: relative;
            padding: 12px 0;
            overflow: hidden;
            /* Override .rack gap - modules sit flush like real Eurorack */
            gap: 0;
        }

        /* Rack rails - the grey bars modules screw into */
        .rack-row::before,
        .rack-row::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 12px;
            z-index: 0;
        }

        .rack-row::before {
            top: 0;
            background: linear-gradient(to bottom, #555, #444);
        }

        .rack-row::after {
            bottom: 0;
            background: linear-gradient(to bottom, #444, #333);
        }

        .rack-row .module {
            height: calc(100% + 24px);
            margin-top: -12px;
            margin-bottom: -12px;
            z-index: 1;
        }

        .rack-row.empty {
            border: 2px dashed #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            color: #555;
            font-size: 12px;
        }

        .rack-row.drag-over {
            background: rgba(100, 200, 100, 0.1);
            border-color: #4a4;
        }

        /* Module drag and remove states */
        .module {
            position: relative;
            cursor: grab;
        }

        .module:active {
            cursor: grabbing;
        }

        .module.dragging {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 0 !important;
            overflow: hidden;
        }


        .module .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: rgba(180, 60, 60, 0.9);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .module:hover .remove-btn {
            opacity: 1;
        }

        .module .remove-btn:hover {
            background: #c44;
        }

        /* Drop zone indicator - ghost of dragged module */
        .drop-indicator {
            height: calc(100% + 24px);
            margin-top: -12px;
            margin-bottom: -12px;
            flex-shrink: 0;
            pointer-events: none;
            z-index: 100;
            opacity: 0.5;
            border: 2px dashed #4a4;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* Row HP indicator */
        .row-hp-indicator {
            position: absolute;
            bottom: -20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: #555;
        }
    </style>
</head>
<body>
<div id="toolbar">
    <div class="toolbar-section">
        <button id="startButton">▶ Start</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <span class="toolbar-label">Patches</span>
        <select id="patchSelect">
            <option value="">-- Select --</option>
        </select>
        <button id="loadPatch">Load</button>
        <button id="deletePatch" class="danger">Del</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <input type="text" id="patchName" placeholder="New patch...">
        <button id="savePatch" class="primary">Save</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button id="copyPatch">Copy</button>
    </div>
    <div class="toolbar-spacer"></div>
    <div class="toolbar-section">
        <button id="clearCables">Clear Cables</button>
    </div>
</div>

<svg id="cable-svg"></svg>

<div class="app-container">
    <div class="sidebar" id="sidebar">
        <!-- Module categories populated by JS -->
    </div>
    <div class="rack-container" id="rack-container">
        <div class="rack rack-row" id="rack-row-1"></div>
        <div class="rack rack-row" id="rack-row-2"></div>
    </div>
</div>

<script type="module">
    /* ========================================================
     * Import modular definitions
     * =========================================================== */
    import { loadModules, moduleRegistry, DEFAULT_MODULE_ORDER } from './js/index.js';
    import { CABLE_COLORS } from './js/config/constants.js';
    import { FACTORY_PATCHES } from './js/config/factory-patches.js';
    import { adjustColor } from './js/utils/color.js';
    import { createAudioEngine } from './js/audio/engine.js';
    import { createCablePath, getJackCenter } from './js/cables/cable-manager.js';

    /* =============================================================
     * Interactive Patcher System
     * -------------------------------------------------------------
     * Renders modules with knobs and jacks, allows cable patching
     * =========================================================== */

    /* Constants imported from js/config/constants.js */
    let colorIndex = 0;

    /* State */
    let audioCtx = null;
    let engine = null;
    let isRunning = false;
    let modules = {};
    let cables = [];
    let dragState = null;

    /* New state for flexible rack */
    const MAX_HP_PER_ROW = 84;
    let instanceCounters = {};  // Counter per module type for unique IDs
    let row1Modules = [];       // Instance IDs in row 1
    let row2Modules = [];       // Instance IDs in row 2
    let draggedModule = null;   // Currently dragged module ID

    /* Module definitions from the self-contained module system */
    const MODULE_ORDER = DEFAULT_MODULE_ORDER;

    /* Category display order and labels */
    const CATEGORY_ORDER = ['clock', 'modulation', 'quantizer', 'voice', 'effect', 'utility', 'output', 'other'];
    const CATEGORY_LABELS = {
        'clock': 'Clock & Utility',
        'modulation': 'Modulation',
        'quantizer': 'Quantizer',
        'voice': 'Voices',
        'effect': 'Effects',
        'utility': 'Utility',
        'output': 'Output',
        'other': 'Other'
    };


    /* =============================================================
     * UI Rendering
     * =========================================================== */

    /* Track injected custom CSS to avoid duplicates */
    const injectedModuleCSS = new Set();

    /**
     * Inject custom CSS for a module (only once per module type)
     * @param {string} moduleType - Module type ID
     * @param {string} css - CSS string to inject
     */
    function injectModuleCSS(moduleType, css) {
        if (injectedModuleCSS.has(moduleType)) return;
        const style = document.createElement('style');
        style.id = `module-css-${moduleType}`;
        style.textContent = css;
        document.head.appendChild(style);
        injectedModuleCSS.add(moduleType);
    }

    /**
     * Create toolkit object for custom render functions
     * Provides helper methods for building module UI
     */
    function createRenderToolkit(moduleId, def) {
        const knobSizeClass = def.hp === 2 ? ' knob-sm' : '';

        return {
            createRow() {
                const row = document.createElement('div');
                row.className = 'jack-row';
                return row;
            },
            createSection(label) {
                const section = document.createElement('div');
                section.className = 'section-label';
                section.textContent = label;
                return section;
            },
            createSpacer() {
                const spacer = document.createElement('div');
                spacer.className = 'spacer';
                return spacer;
            },
            createLED({ id, color = 'green' }) {
                const led = document.createElement('div');
                led.className = `led ${color}`;
                led.id = `led-${moduleId}-${id}`;
                return led;
            },
            createKnob({ id, label, value = 0.5, min = 0, max = 1, step = 0, param, onChange, small = false }) {
                const container = document.createElement('div');
                container.className = 'knob-container';

                const knob = document.createElement('div');
                knob.className = `knob${small ? ' knob-sm' : knobSizeClass}`;
                knob.id = `knob-${moduleId}-${id}`;
                knob.dataset.module = moduleId;
                knob.dataset.param = param || id;
                knob.dataset.min = min;
                knob.dataset.max = max;
                knob.dataset.value = value;
                knob.dataset.step = step;

                const labelEl = document.createElement('div');
                labelEl.className = 'knob-label';
                labelEl.textContent = label;

                container.appendChild(knob);
                container.appendChild(labelEl);

                // Store onChange callback for later binding
                if (onChange) {
                    knob._onChange = onChange;
                }

                return container;
            },
            createSwitch({ id, label, value = 0, param, onChange }) {
                const container = document.createElement('div');
                container.className = 'knob-container';

                const sw = document.createElement('div');
                sw.className = `switch ${value ? 'on' : ''}`;
                sw.id = `switch-${moduleId}-${id}`;
                sw.dataset.module = moduleId;
                sw.dataset.param = param || id;

                const labelEl = document.createElement('div');
                labelEl.className = 'knob-label';
                labelEl.textContent = label;

                container.appendChild(sw);
                container.appendChild(labelEl);

                // Store onChange callback
                if (onChange) {
                    sw._onChange = onChange;
                }

                return container;
            },
            createJack({ id, label, direction, type = 'buffer' }) {
                const container = document.createElement('div');
                container.className = 'jack-container';

                const jack = document.createElement('div');
                jack.className = `jack ${direction}`;
                jack.id = `jack-${moduleId}-${id}`;
                jack.dataset.module = moduleId;
                jack.dataset.port = id;
                jack.dataset.dir = direction;
                jack.dataset.type = type;

                const labelEl = document.createElement('div');
                labelEl.className = 'jack-label';
                labelEl.textContent = label;

                container.appendChild(jack);
                container.appendChild(labelEl);

                return container;
            },
            createCanvas({ width = 100, height = 60, className = 'module-canvas' }) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                canvas.className = className;
                return canvas;
            }
        };
    }

    function renderModule(type, id) {
        const def = moduleRegistry.get(type);
        const ui = def.ui || {};
        const el = document.createElement('div');
        el.className = `module module-${def.hp}hp`;
        el.id = `module-${id}`;
        el.style.background = `linear-gradient(to bottom, ${def.color}, ${adjustColor(def.color, -30)})`;

        // Inject custom CSS if module defines it
        if (def.css) {
            injectModuleCSS(def.id, def.css);
        }

        // Check if module has custom render function
        if (def.render) {
            // Create basic structure
            const label = document.createElement('div');
            label.className = 'module-label';
            label.textContent = def.name;
            el.appendChild(label);

            const content = document.createElement('div');
            content.className = 'module-content';
            el.appendChild(content);

            // Store render info for later execution (after DSP is created)
            el._customRender = {
                render: def.render,
                content: content,
                toolkit: createRenderToolkit(id, def)
            };

            return el;
        }

        // Standard declarative rendering
        let html = `<div class="module-label">${def.name}</div><div class="module-content">`;

        /* LEDs */
        if (ui.leds && ui.leds.length > 0) {
            html += '<div class="jack-row">';
            ui.leds.forEach(led => {
                html += `<div class="led green" id="led-${id}-${led}"></div>`;
            });
            html += '</div>';
        }

        /* Knobs - render in a row if more than 2 */
        const knobs = ui.knobs || [];
        if (knobs.length > 2) {
            html += '<div class="jack-row">';
        }
        const knobSizeClass = def.hp === 2 ? ' knob-sm' : '';
        knobs.forEach(knob => {
            html += `
                <div class="knob-container">
                    <div class="knob${knobSizeClass}" id="knob-${id}-${knob.id}"
                         data-module="${id}" data-param="${knob.param}"
                         data-min="${knob.min}" data-max="${knob.max}"
                         data-value="${knob.default}" data-step="${knob.step || 0}"></div>
                    <div class="knob-label">${knob.label}</div>
                </div>`;
        });
        if (knobs.length > 2) {
            html += '</div>';
        }

        /* Switches - render in a row */
        const switches = ui.switches || [];
        if (switches.length > 0) {
            html += '<div class="jack-row">';
            switches.forEach(sw => {
                html += `
                    <div class="knob-container">
                        <div class="switch ${sw.default ? 'on' : ''}" id="switch-${id}-${sw.id}"
                             data-module="${id}" data-param="${sw.param}"></div>
                        <div class="knob-label">${sw.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Button banks (octave select) or toggle buttons (gate on/off) */
        const buttons = ui.buttons || [];
        if (buttons.length > 0) {
            // Check if first button has 'values' array (octave-style) or 'param' (toggle-style)
            if (buttons[0].values) {
                // Octave-select style button banks
                buttons.forEach(btnGroup => {
                    html += `<div class="section-label">${btnGroup.label}</div><div class="button-bank" data-module="${id}" data-param="${btnGroup.param}">`;
                    btnGroup.values.forEach((val, idx) => {
                        const isActive = val === btnGroup.default;
                        html += `<button class="octave-btn${isActive ? ' active' : ''}" data-value="${val}">${val > 0 ? '+' + val : val}</button>`;
                    });
                    html += '</div>';
                });
            } else {
                // Toggle-style buttons (gate on/off)
                html += `<div class="section-label">Gates</div><div class="toggle-row">`;
                buttons.forEach(btn => {
                    const isActive = btn.default === 1;
                    html += `<button class="toggle-btn${isActive ? ' active' : ''}" data-module="${id}" data-param="${btn.param}" title="${btn.label}"></button>`;
                });
                html += '</div>';
            }
        }

        html += '<div class="spacer"></div>';

        /* Outputs */
        const outputs = ui.outputs || [];
        if (outputs.length > 0) {
            html += '<div class="section-label">Out</div><div class="jack-row">';
            outputs.forEach(out => {
                html += `
                    <div class="jack-container">
                        <div class="jack output" id="jack-${id}-${out.id}"
                             data-module="${id}" data-port="${out.port}" data-dir="output" data-type="${out.type}"></div>
                        <div class="jack-label">${out.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Inputs - group by type for larger modules */
        const inputs = ui.inputs || [];
        if (inputs.length > 0) {
            if (inputs.length > 4) {
                /* Split inputs into groups (CV and triggers) */
                const cvInputs = inputs.filter(i => i.type === 'cv' || i.id.startsWith('cv'));
                const trigInputs = inputs.filter(i => i.type === 'trigger' || i.id.startsWith('trig'));
                const otherInputs = inputs.filter(i =>
                    i.type !== 'cv' && i.type !== 'trigger' &&
                    !i.id.startsWith('cv') && !i.id.startsWith('trig'));

                if (cvInputs.length > 0) {
                    html += '<div class="section-label">CV In</div><div class="jack-row">';
                    cvInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (trigInputs.length > 0) {
                    html += '<div class="section-label">Trig In</div><div class="jack-row">';
                    trigInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (otherInputs.length > 0) {
                    html += '<div class="section-label">In</div><div class="jack-row">';
                    otherInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
            } else {
                html += '<div class="section-label">In</div><div class="jack-row">';
                inputs.forEach(inp => {
                    html += `
                        <div class="jack-container">
                            <div class="jack input" id="jack-${id}-${inp.id}"
                                 data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                            <div class="jack-label">${inp.label}</div>
                        </div>`;
                });
                html += '</div>';
            }
        }

        html += '</div>';
        el.innerHTML = html;
        return el;
    }

    function updateKnobRotation(knobEl) {
        const min = parseFloat(knobEl.dataset.min);
        const max = parseFloat(knobEl.dataset.max);
        const value = parseFloat(knobEl.dataset.value);
        const rotation = -135 + ((value - min) / (max - min)) * 270;
        knobEl.style.setProperty('--rotation', `${rotation}deg`);
        const indicator = knobEl.querySelector('::after') || knobEl;
        knobEl.style.transform = `rotate(${rotation}deg)`;
    }

    /* =============================================================
     * Sidebar & Module Management
     * =========================================================== */

    function populateSidebar() {
        const sidebar = document.getElementById('sidebar');
        sidebar.innerHTML = '';

        // Get all registered categories
        const registeredCategories = moduleRegistry.getCategories();

        // Build category -> modules map
        const categoryModules = {};
        CATEGORY_ORDER.forEach(cat => {
            categoryModules[cat] = [];
        });

        // Populate with modules from registry
        registeredCategories.forEach(cat => {
            const targetCat = CATEGORY_ORDER.includes(cat) ? cat : 'other';
            const mods = moduleRegistry.getByCategory(cat);
            categoryModules[targetCat].push(...mods);
        });

        // Render each category
        CATEGORY_ORDER.forEach(cat => {
            const mods = categoryModules[cat];
            if (mods.length === 0) return;

            const categoryEl = document.createElement('div');
            categoryEl.className = 'sidebar-category';
            categoryEl.textContent = CATEGORY_LABELS[cat] || cat;
            sidebar.appendChild(categoryEl);

            mods.forEach(def => {
                const modEl = document.createElement('div');
                modEl.className = 'sidebar-module';
                modEl.dataset.moduleType = def.id;
                modEl.innerHTML = `
                    <div class="sidebar-module-color" style="background: ${def.color}"></div>
                    <div class="sidebar-module-name">${def.name}</div>
                    <div class="sidebar-module-hp">${def.hp}hp</div>
                `;
                modEl.addEventListener('click', () => addModuleToRack(def.id));
                sidebar.appendChild(modEl);
            });
        });
    }

    function getRowHP(rowModules) {
        return rowModules.reduce((sum, id) => {
            const mod = modules[id];
            return sum + (mod ? mod.def.hp : 0);
        }, 0);
    }

    function generateInstanceId(moduleType) {
        if (!instanceCounters[moduleType]) {
            instanceCounters[moduleType] = 0;
        }
        instanceCounters[moduleType]++;
        return `${moduleType}_${instanceCounters[moduleType]}`;
    }

    function addModuleToRack(moduleType, targetRow = null, targetPosition = null, forceInstanceId = null) {
        const def = moduleRegistry.get(moduleType);
        if (!def) {
            console.warn(`Module type "${moduleType}" not found`);
            return null;
        }

        const hp = def.hp;
        const row1HP = getRowHP(row1Modules);
        const row2HP = getRowHP(row2Modules);

        // Determine which row to add to
        let row, rowModules, rowEl;
        const row1Fits = row1HP + hp <= MAX_HP_PER_ROW;
        const row2Fits = row2HP + hp <= MAX_HP_PER_ROW;

        if (row1Fits) {
            row = 1;
            rowModules = row1Modules;
            rowEl = document.getElementById('rack-row-1');
        } else if (row2Fits) {
            row = 2;
            rowModules = row2Modules;
            rowEl = document.getElementById('rack-row-2');
        } else {
            return null;
        }

        // Use provided instance ID or generate a new one
        const instanceId = forceInstanceId || generateInstanceId(moduleType);

        // Create module element
        const el = renderModule(moduleType, instanceId);
        el.dataset.instanceId = instanceId;
        el.dataset.row = row;

        // Add remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerHTML = '×';
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeModuleFromRack(instanceId);
        });
        el.appendChild(removeBtn);

        // Add mouse-based drag handler
        el.addEventListener('mousedown', handleModuleMouseDown);

        // Create DSP instance if audio is running
        let instance = null;
        if (audioCtx) {
            instance = def.createDSP({
                sampleRate: audioCtx.sampleRate,
                bufferSize: 512,
                audioCtx: audioCtx
            });
        }

        // Store in modules map
        modules[instanceId] = { def, el, instance, type: moduleType, row };

        // Execute custom render function if present
        if (el._customRender) {
            const { render, content, toolkit } = el._customRender;
            const mod = modules[instanceId];
            render(content, {
                instance: {
                    id: instanceId,
                    type: moduleType,
                    def: def,
                    dsp: instance, // May be null if audio not started
                    element: el,
                    getModule: () => mod // Allow render to access updated module state
                },
                toolkit,
                onParamChange: (param, value) => {
                    if (mod.instance) {
                        mod.instance.params[param] = value;
                    }
                }
            });
            delete el._customRender;
        }

        // Add to row
        if (targetPosition !== null && targetPosition < rowModules.length) {
            const beforeEl = document.getElementById(`module-${rowModules[targetPosition]}`);
            rowEl.insertBefore(el, beforeEl);
            rowModules.splice(targetPosition, 0, instanceId);
        } else {
            rowEl.appendChild(el);
            rowModules.push(instanceId);
        }

        // Update row empty state
        rowEl.classList.remove('empty');

        // Initialize knob rotations
        el.querySelectorAll('.knob').forEach(updateKnobRotation);

        // Update engine if running
        updateEngineModules();

        return instanceId;
    }

    function removeModuleFromRack(instanceId) {
        const mod = modules[instanceId];
        if (!mod) return;

        // Remove connected cables
        const connectedCables = cables.filter(c =>
            c.fromModule === instanceId || c.toModule === instanceId
        );
        connectedCables.forEach(removeCable);

        // Remove from DOM
        mod.el.remove();

        // Remove from row array
        const row1Idx = row1Modules.indexOf(instanceId);
        if (row1Idx >= 0) {
            row1Modules.splice(row1Idx, 1);
            if (row1Modules.length === 0) {
                document.getElementById('rack-row-1').classList.add('empty');
            }
        }
        const row2Idx = row2Modules.indexOf(instanceId);
        if (row2Idx >= 0) {
            row2Modules.splice(row2Idx, 1);
            if (row2Modules.length === 0) {
                document.getElementById('rack-row-2').classList.add('empty');
            }
        }

        // Remove from modules map
        delete modules[instanceId];

        // Update engine
        updateEngineModules();

        // Redraw remaining cables (modules shifted positions)
        requestAnimationFrame(() => cables.forEach(renderCable));
    }

    function updateEngineModules() {
        if (engine) {
            engine.setModules(modules);
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }
    }

    /* =============================================================
     * Module Drag and Drop (Mouse-based for full control)
     * =========================================================== */

    let dropIndicator = null;
    let draggedModuleEl = null;
    let isDragging = false;

    function createDropIndicator(sourceModuleEl) {
        if (dropIndicator) {
            dropIndicator.remove();
        }
        dropIndicator = sourceModuleEl.cloneNode(true);
        dropIndicator.className = 'module drop-indicator';
        dropIndicator.id = '';
        dropIndicator.style.width = sourceModuleEl.offsetWidth + 'px';
        // Remove interactive elements
        dropIndicator.querySelectorAll('.remove-btn').forEach(el => el.remove());
        return dropIndicator;
    }

    function removeDropIndicator() {
        if (dropIndicator && dropIndicator.parentNode) {
            dropIndicator.parentNode.removeChild(dropIndicator);
        }
        dropIndicator = null;
    }

    // Find drop position in a row based on cursor X
    function findDropPosition(rowEl, clientX, excludeId) {
        let moduleEls = Array.from(rowEl.querySelectorAll('.module:not(.drop-indicator)'));
        if (excludeId) {
            moduleEls = moduleEls.filter(el => el.dataset.instanceId !== excludeId);
        }

        if (moduleEls.length === 0) {
            return { beforeEl: null };
        }

        // Check if before first module
        const firstRect = moduleEls[0].getBoundingClientRect();
        if (clientX < firstRect.left + firstRect.width / 2) {
            return { beforeEl: moduleEls[0] };
        }

        // Check each module
        for (let i = 0; i < moduleEls.length; i++) {
            const rect = moduleEls[i].getBoundingClientRect();
            const midX = rect.left + rect.width / 2;

            if (clientX < midX) {
                return { beforeEl: moduleEls[i] };
            }
        }

        // After last module
        return { beforeEl: null };
    }

    function handleModuleMouseDown(e) {
        // Only left click, and not on interactive elements
        if (e.button !== 0) return;
        if (e.target.closest('.jack, .knob, .switch, .remove-btn, .octave-btn, .toggle-btn')) return;

        const moduleEl = e.target.closest('.module');
        if (!moduleEl) return;

        e.preventDefault();

        draggedModule = moduleEl.dataset.instanceId;
        draggedModuleEl = moduleEl;
        isDragging = true;

        // Create the drop indicator and insert it at the original position
        createDropIndicator(moduleEl);
        moduleEl.parentNode.insertBefore(dropIndicator, moduleEl);

        // Hide the original (it stays in DOM to maintain layout reference)
        moduleEl.classList.add('dragging');

        // Add move and up listeners to document
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
    }

    function handleDragMove(e) {
        if (!isDragging || !draggedModuleEl) return;

        // Find which row we're over
        const rowEls = document.querySelectorAll('.rack-row');
        let targetRow = null;

        for (const rowEl of rowEls) {
            const rect = rowEl.getBoundingClientRect();
            if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                targetRow = rowEl;
                break;
            }
        }

        // Clear all drag-over states
        rowEls.forEach(el => el.classList.remove('drag-over'));

        if (!targetRow) {
            // Not over any row - put ghost back in original position
            const originalRow = draggedModuleEl.parentNode;
            if (dropIndicator && dropIndicator.parentNode !== originalRow) {
                originalRow.insertBefore(dropIndicator, draggedModuleEl);
            }
            return;
        }

        targetRow.classList.add('drag-over');

        // Find where to show the drop indicator (don't exclude dragged module)
        const { beforeEl } = findDropPosition(targetRow, e.clientX, null);

        // Ensure indicator exists
        if (!dropIndicator) {
            createDropIndicator(draggedModuleEl);
        }

        // Insert indicator at position (it will replace the invisible original visually)
        if (beforeEl) {
            // Don't insert before the dragged element itself
            if (beforeEl !== draggedModuleEl) {
                targetRow.insertBefore(dropIndicator, beforeEl);
            } else {
                // Insert before the dragged element (which is invisible)
                targetRow.insertBefore(dropIndicator, draggedModuleEl);
            }
        } else {
            targetRow.appendChild(dropIndicator);
        }

        // Redraw cables to follow the ghost
        cables.forEach(renderCable);
    }

    function handleDragEnd(e) {
        if (!isDragging) return;

        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);

        // If we have a drop indicator, perform the drop
        if (dropIndicator && dropIndicator.parentNode) {
            const rowEl = dropIndicator.parentNode;
            const targetRow = rowEl.id === 'rack-row-1' ? 1 : 2;
            const draggedMod = modules[draggedModule];

            if (draggedMod) {
                const targetRowModules = targetRow === 1 ? row1Modules : row2Modules;
                const fromRow = draggedMod.row;
                const fromRowModules = fromRow === 1 ? row1Modules : row2Modules;

                // Check if it fits in target row (if changing rows)
                let canDrop = true;
                if (fromRow !== targetRow) {
                    const currentHP = getRowHP(targetRowModules);
                    if (currentHP + draggedMod.def.hp > MAX_HP_PER_ROW) {
                        canDrop = false;
                    }
                }

                if (canDrop) {
                    // Find the beforeEl from the drop indicator's current position
                    const beforeEl = dropIndicator.nextElementSibling;

                    // Remove from current position in array
                    const fromIdx = fromRowModules.indexOf(draggedModule);
                    if (fromIdx >= 0) {
                        fromRowModules.splice(fromIdx, 1);
                    }

                    // Find where to insert based on beforeEl
                    let insertIdx;
                    if (beforeEl && beforeEl.classList.contains('module')) {
                        const beforeId = beforeEl.dataset.instanceId;
                        insertIdx = targetRowModules.indexOf(beforeId);
                        if (insertIdx === -1) insertIdx = targetRowModules.length;
                    } else {
                        insertIdx = targetRowModules.length;
                    }

                    // Insert at new position
                    targetRowModules.splice(insertIdx, 0, draggedModule);
                    draggedMod.row = targetRow;
                    draggedMod.el.dataset.row = targetRow;

                    // Update DOM - insert at correct position
                    if (beforeEl && beforeEl.classList.contains('module')) {
                        rowEl.insertBefore(draggedMod.el, beforeEl);
                    } else {
                        rowEl.appendChild(draggedMod.el);
                    }

                    // Update empty states
                    const fromRowEl = document.getElementById(`rack-row-${fromRow}`);
                    if (fromRowModules.length === 0) {
                        fromRowEl.classList.add('empty');
                    }
                    rowEl.classList.remove('empty');

                    // Redraw cables
                    cables.forEach(renderCable);
                }
            }
        }

        // Clean up
        if (draggedModuleEl) {
            draggedModuleEl.classList.remove('dragging');
        }
        removeDropIndicator();
        document.querySelectorAll('.rack-row').forEach(el => {
            el.classList.remove('drag-over');
        });

        draggedModule = null;
        draggedModuleEl = null;
        isDragging = false;
    }

    /* =============================================================
     * Cable System
     * =========================================================== */
    const svgNS = 'http://www.w3.org/2000/svg';
    const cableSvg = document.getElementById('cable-svg');

    function renderCable(cable) {
        // If a module is being dragged, use ghost jacks instead of original jacks
        let fromEl = cable.fromEl;
        let toEl = cable.toEl;

        if (dropIndicator && draggedModuleEl) {
            // Check if this cable connects to the dragged module
            if (cable.fromModule === draggedModule) {
                const ghostJack = dropIndicator.querySelector(`.jack[data-port="${cable.fromPort}"]`);
                if (ghostJack) fromEl = ghostJack;
            }
            if (cable.toModule === draggedModule) {
                const ghostJack = dropIndicator.querySelector(`.jack[data-port="${cable.toPort}"]`);
                if (ghostJack) toEl = ghostJack;
            }
        }

        const from = getJackCenter(fromEl);
        const to = getJackCenter(toEl);
        cable.pathEl.setAttribute('d', createCablePath(from.x, from.y, to.x, to.y));
    }

    function addCable(fromJack, toJack, color = null) {
        const path = document.createElementNS(svgNS, 'path');
        path.classList.add('cable');
        /* Use provided color or get next color from palette */
        path.style.stroke = color || CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
        cableSvg.appendChild(path);

        const cable = {
            fromEl: fromJack,
            toEl: toJack,
            pathEl: path,
            fromModule: fromJack.dataset.module,
            fromPort: fromJack.dataset.port,
            toModule: toJack.dataset.module,
            toPort: toJack.dataset.port,
            type: fromJack.dataset.type
        };

        cables.push(cable);
        fromJack.classList.add('connected');
        toJack.classList.add('connected');
        renderCable(cable);

        /* Update engine with new cable state */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }

        return cable;
    }

    function removeCable(cable) {
        if (cable.pathEl) cable.pathEl.remove();
        if (cable.fromEl) cable.fromEl.classList.remove('connected');
        if (cable.toEl) cable.toEl.classList.remove('connected');
        cables = cables.filter(c => c !== cable);

        /* Update engine with new cable state - handles audio input clearing */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }
    }

    function clearAllCables() {
        cables.forEach(c => {
            c.pathEl.remove();
            c.fromEl.classList.remove('connected');
            c.toEl.classList.remove('connected');
        });
        cables = [];

        /* Update engine with empty cables - handles audio input clearing */
        if (engine) {
            engine.setCables([]);
        }
    }

    /* Preview cable while dragging */
    let previewPath = null;

    function startDrag(jackEl, e) {
        /* Check if this jack has an existing cable connected */
        const existingCable = cables.find(c => c.fromEl === jackEl || c.toEl === jackEl);

        if (existingCable) {
            /* Detach the cable from this jack, drag from the other end */
            const isFromEnd = existingCable.fromEl === jackEl;
            const anchorJack = isFromEnd ? existingCable.toEl : existingCable.fromEl;
            const cableColor = existingCable.pathEl.style.stroke;

            /* Remove the existing cable */
            removeCable(existingCable);

            /* Start dragging from the anchor (the other end) */
            dragState = {
                startJack: anchorJack,
                startDir: anchorJack.dataset.dir,
                reconnecting: true
            };

            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = cableColor;
            cableSvg.appendChild(previewPath);
        } else {
            /* No existing cable - start new connection */
            dragState = {
                startJack: jackEl,
                startDir: jackEl.dataset.dir,
                reconnecting: false
            };
            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
            cableSvg.appendChild(previewPath);
        }
        updatePreview(e);
    }

    function updatePreview(e) {
        if (!dragState || !previewPath) return;
        const start = getJackCenter(dragState.startJack);
        const end = {x: e.clientX, y: e.clientY};
        previewPath.setAttribute('d', createCablePath(start.x, start.y, end.x, end.y));
    }

    function endDrag(targetJack, e) {
        if (!dragState) return;

        const cableColor = previewPath ? previewPath.style.stroke : CABLE_COLORS[colorIndex % CABLE_COLORS.length];

        if (previewPath) {
            previewPath.remove();
            previewPath = null;
        }

        let connected = false;

        if (targetJack && targetJack !== dragState.startJack) {
            const startDir = dragState.startDir;
            const endDir = targetJack.dataset.dir;

            /* Must connect output to input (different directions) */
            if (startDir !== endDir) {
                const fromJack = startDir === 'output' ? dragState.startJack : targetJack;
                const toJack = startDir === 'input' ? dragState.startJack : targetJack;

                /* Remove existing cable to this input (unless shift is held for stacking) */
                const existing = cables.find(c => c.toEl === toJack);
                if (existing && !(e && e.shiftKey)) removeCable(existing);

                addCable(fromJack, toJack, cableColor);
                connected = true;
            }
        }

        /* If reconnecting and dropped on invalid target, cable is removed (already done in startDrag) */
        /* If new cable and dropped on invalid target, nothing happens */

        dragState = null;
    }

    /* =============================================================
     * Knob Interaction
     * =========================================================== */
    let knobDrag = null;

    function startKnobDrag(knobEl, e) {
        knobDrag = {
            knob: knobEl,
            startY: e.clientY,
            startValue: parseFloat(knobEl.dataset.value)
        };
    }

    function updateKnobDrag(e) {
        if (!knobDrag) return;
        const knob = knobDrag.knob;
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const step = parseFloat(knob.dataset.step) || 0;
        const range = max - min;
        const dy = knobDrag.startY - e.clientY;
        let newValue = knobDrag.startValue + (dy / 150) * range;

        if (step > 0) {
            newValue = Math.round(newValue / step) * step;
        }
        newValue = Math.max(min, Math.min(max, newValue));

        knob.dataset.value = newValue;
        updateKnobRotation(knob);

        /* Update module param */
        const moduleId = knob.dataset.module;
        const param = knob.dataset.param;
        if (modules[moduleId] && modules[moduleId].instance) {
            modules[moduleId].instance.params[param] = newValue;
        }
    }

    function endKnobDrag() {
        knobDrag = null;
    }

    /* =============================================================
     * Patch Bank System
     * -------------------------------------------------------------
     * Save and load patches to/from localStorage
     * =========================================================== */
    const PATCH_STORAGE_KEY = 'eurorack-patches';


    function getPatchList() {
        try {
            const data = localStorage.getItem(PATCH_STORAGE_KEY);
            const userPatches = data ? JSON.parse(data) : {};
            /* Merge factory patches with user patches (user patches take precedence) */
            return { ...FACTORY_PATCHES, ...userPatches };
        } catch (e) {
            console.error('Error loading patches:', e);
            return { ...FACTORY_PATCHES };
        }
    }

    function serializeCurrentState() {
        const state = {
            modules: [],   // Module layout: [{type, instanceId, row}]
            knobs: {},
            switches: {},
            buttons: {},
            cables: []
        };

        /* Serialize module layout */
        row1Modules.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                state.modules.push({ type: mod.type, instanceId, row: 1 });
            }
        });
        row2Modules.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                state.modules.push({ type: mod.type, instanceId, row: 2 });
            }
        });

        /* Serialize all knob values */
        document.querySelectorAll('.knob').forEach(knob => {
            const moduleId = knob.dataset.module;
            const param = knob.dataset.param;
            const value = parseFloat(knob.dataset.value);
            if (!state.knobs[moduleId]) state.knobs[moduleId] = {};
            state.knobs[moduleId][param] = value;
        });

        /* Serialize all switch states */
        document.querySelectorAll('.switch').forEach(sw => {
            const moduleId = sw.dataset.module;
            const param = sw.dataset.param;
            const isOn = sw.classList.contains('on');
            if (!state.switches[moduleId]) state.switches[moduleId] = {};
            state.switches[moduleId][param] = isOn;
        });

        /* Serialize all button bank states */
        document.querySelectorAll('.button-bank').forEach(bank => {
            const moduleId = bank.dataset.module;
            const param = bank.dataset.param;
            const activeBtn = bank.querySelector('.octave-btn.active');
            const value = activeBtn ? parseInt(activeBtn.dataset.value) : 0;
            if (!state.buttons[moduleId]) state.buttons[moduleId] = {};
            state.buttons[moduleId][param] = value;
        });

        /* Serialize all toggle button states */
        document.querySelectorAll('.toggle-btn').forEach(btn => {
            const moduleId = btn.dataset.module;
            const param = btn.dataset.param;
            const isActive = btn.classList.contains('active');
            if (!state.buttons[moduleId]) state.buttons[moduleId] = {};
            state.buttons[moduleId][param] = isActive ? 1 : 0;
        });

        /* Serialize cable connections */
        cables.forEach(cable => {
            state.cables.push({
                fromModule: cable.fromModule,
                fromPort: cable.fromPort,
                toModule: cable.toModule,
                toPort: cable.toPort
            });
        });

        return state;
    }

    function clearRack() {
        /* Remove all modules from rack */
        const allModuleIds = [...row1Modules, ...row2Modules];
        allModuleIds.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                mod.el.remove();
                delete modules[instanceId];
            }
        });
        row1Modules.length = 0;
        row2Modules.length = 0;
        instanceCounters = {};

        /* Mark rows as empty */
        document.getElementById('rack-row-1').classList.add('empty');
        document.getElementById('rack-row-2').classList.add('empty');
    }

    function applyPatchState(state) {
        /* Clear existing cables */
        clearAllCables();

        /* Build ID mapping for old-style patches */
        const idMapping = {};

        /* Handle module layout - new format includes modules array */
        if (state.modules && state.modules.length > 0) {
            /* Clear existing rack and rebuild from saved layout */
            clearRack();

            state.modules.forEach(modInfo => {
                const { type, instanceId, row } = modInfo;
                /* Pass the saved instanceId to preserve exact IDs */
                addModuleToRack(type, row, null, instanceId);
            });
        } else {
            /* Legacy patch format - use MODULE_ORDER if no layout and rack is empty */
            if (row1Modules.length === 0 && row2Modules.length === 0) {
                MODULE_ORDER.forEach(type => {
                    const newId = addModuleToRack(type);
                    idMapping[type] = newId;
                });
            } else {
                /* Keep current modules, map old type-based IDs to current instance IDs */
                Object.keys(modules).forEach(instanceId => {
                    const mod = modules[instanceId];
                    idMapping[mod.type] = instanceId;
                });
            }
        }

        /* Helper to resolve module ID (handles both old and new formats) */
        const resolveModuleId = (savedId) => idMapping[savedId] || savedId;

        /* Apply knob values */
        if (state.knobs) {
            Object.entries(state.knobs).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, value]) => {
                    const knob = document.querySelector(`.knob[data-module="${moduleId}"][data-param="${param}"]`);
                    if (knob) {
                        knob.dataset.value = value;
                        updateKnobRotation(knob);
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    }
                });
            });
        }

        /* Apply switch states */
        if (state.switches) {
            Object.entries(state.switches).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, isOn]) => {
                    const sw = document.querySelector(`.switch[data-module="${moduleId}"][data-param="${param}"]`);
                    if (sw) {
                        sw.classList.toggle('on', isOn);
                        if (modules[moduleId]?.instance) {
                            if (param.includes('[')) {
                                const match = param.match(/(\w+)\[(\d+)\]/);
                                if (match) {
                                    modules[moduleId].instance.params[match[1]][parseInt(match[2])] = isOn;
                                }
                            } else {
                                modules[moduleId].instance.params[param] = isOn ? 1 : 0;
                            }
                        }
                    }
                });
            });
        }

        /* Apply button bank and toggle button states */
        if (state.buttons) {
            Object.entries(state.buttons).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, value]) => {
                    // Try button bank first
                    const bank = document.querySelector(`.button-bank[data-module="${moduleId}"][data-param="${param}"]`);
                    if (bank) {
                        bank.querySelectorAll('.octave-btn').forEach(btn => {
                            btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
                        });
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    } else {
                        // Try toggle button
                        const toggleBtn = document.querySelector(`.toggle-btn[data-module="${moduleId}"][data-param="${param}"]`);
                        if (toggleBtn) {
                            toggleBtn.classList.toggle('active', value === 1);
                            if (modules[moduleId]?.instance) {
                                modules[moduleId].instance.params[param] = value;
                            }
                        }
                    }
                });
            });
        }

        /* Apply cable connections */
        if (state.cables) {
            state.cables.forEach(conn => {
                const fromModule = resolveModuleId(conn.fromModule);
                const toModule = resolveModuleId(conn.toModule);
                /* Find jacks by module, port, and direction (output→input) */
                const fromJack = document.querySelector(`.jack.output[data-module="${fromModule}"][data-port="${conn.fromPort}"]`);
                const toJack = document.querySelector(`.jack.input[data-module="${toModule}"][data-port="${conn.toPort}"]`);
                if (fromJack && toJack) {
                    addCable(fromJack, toJack);
                }
            });
        }
    }

    function savePatch(name) {
        if (!name || !name.trim()) {
            alert('Please enter a patch name');
            return false;
        }
        name = name.trim();

        /* Only save to user patches, not the merged list */
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        userPatches[name] = {
            name: name,
            created: new Date().toISOString(),
            state: serializeCurrentState()
        };

        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(userPatches));
        updatePatchSelect();
        return true;
    }

    function loadPatch(name) {
        const patches = getPatchList();
        if (!patches[name]) {
            alert('Patch not found');
            return false;
        }

        applyPatchState(patches[name].state);
        return true;
    }

    function deletePatch(name) {
        if (!name) return false;

        /* Cannot delete factory patches */
        if (FACTORY_PATCHES[name]) {
            alert('Cannot delete factory patches');
            return false;
        }

        const patches = getPatchList();
        if (!patches[name]) return false;

        if (!confirm(`Delete patch "${name}"?`)) return false;

        /* Only delete from user patches in localStorage */
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        delete userPatches[name];
        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(userPatches));
        updatePatchSelect();
        return true;
    }

    function copyPatchToClipboard() {
        const state = serializeCurrentState();
        const json = JSON.stringify(state, null, 4);
        navigator.clipboard.writeText(json).then(() => {
            const btn = document.getElementById('copyPatch');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = originalText, 1500);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    }

    function updatePatchSelect() {
        const select = document.getElementById('patchSelect');

        /* Clear all children except the first placeholder option */
        while (select.children.length > 1) {
            select.removeChild(select.lastChild);
        }

        /* Separate factory and user patches */
        const factoryNames = Object.keys(FACTORY_PATCHES).sort();
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        const userNames = Object.keys(userPatches).sort();

        /* Add factory patches group */
        if (factoryNames.length > 0) {
            const factoryGroup = document.createElement('optgroup');
            factoryGroup.label = 'Factory Patches';
            factoryNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                factoryGroup.appendChild(option);
            });
            select.appendChild(factoryGroup);
        }

        /* Add user patches group */
        if (userNames.length > 0) {
            const userGroup = document.createElement('optgroup');
            userGroup.label = 'My Patches';
            userNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                userGroup.appendChild(option);
            });
            select.appendChild(userGroup);
        }
    }

    function initPatchBank() {
        /* Update patch list dropdown */
        updatePatchSelect();

        /* Save button */
        document.getElementById('savePatch').addEventListener('click', () => {
            const nameInput = document.getElementById('patchName');
            if (savePatch(nameInput.value)) {
                /* Select the newly saved patch */
                document.getElementById('patchSelect').value = nameInput.value.trim();
                nameInput.value = '';
            }
        });

        /* Load button */
        document.getElementById('loadPatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });

        /* Delete button */
        document.getElementById('deletePatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                deletePatch(select.value);
                select.value = '';
            }
        });

        /* Allow Enter key to save */
        document.getElementById('patchName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('savePatch').click();
            }
        });

        /* Double-click on select to load */
        document.getElementById('patchSelect').addEventListener('dblclick', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });
    }

    /* =============================================================
     * Initialization
     * =========================================================== */
    async function init() {
        /* Load all module definitions into registry */
        await loadModules();

        /* Populate sidebar with available modules */
        populateSidebar();

        /* Set up rack rows */
        const row1 = document.getElementById('rack-row-1');
        const row2 = document.getElementById('rack-row-2');

        /* Mark rows as empty initially */
        row1.classList.add('empty');
        row2.classList.add('empty');


        /* Event listeners */
        document.addEventListener('mousedown', e => {
            const jack = e.target.closest('.jack');
            const knob = e.target.closest('.knob');
            const sw = e.target.closest('.switch');
            const octBtn = e.target.closest('.octave-btn');
            const toggleBtn = e.target.closest('.toggle-btn');

            if (jack) {
                e.preventDefault();
                /* Right-click to remove cables */
                if (e.button === 2) {
                    const cable = cables.find(c => c.fromEl === jack || c.toEl === jack);
                    if (cable) removeCable(cable);
                } else {
                    startDrag(jack, e);
                }
            } else if (knob) {
                e.preventDefault();
                startKnobDrag(knob, e);
            } else if (sw) {
                e.preventDefault();
                sw.classList.toggle('on');
                const moduleId = sw.dataset.module;
                const param = sw.dataset.param;
                if (modules[moduleId]?.instance) {
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        modules[moduleId].instance.params[match[1]][parseInt(match[2])] = sw.classList.contains('on');
                    } else {
                        modules[moduleId].instance.params[param] = sw.classList.contains('on') ? 1 : 0;
                    }
                }
            } else if (octBtn) {
                e.preventDefault();
                const bank = octBtn.closest('.button-bank');
                const moduleId = bank.dataset.module;
                const param = bank.dataset.param;
                const value = parseInt(octBtn.dataset.value);
                /* Toggle active state */
                bank.querySelectorAll('.octave-btn').forEach(b => b.classList.remove('active'));
                octBtn.classList.add('active');
                /* Update module param */
                if (modules[moduleId]?.instance) {
                    modules[moduleId].instance.params[param] = value;
                }
            } else if (toggleBtn) {
                e.preventDefault();
                toggleBtn.classList.toggle('active');
                const moduleId = toggleBtn.dataset.module;
                const param = toggleBtn.dataset.param;
                /* Update module param */
                if (modules[moduleId]?.instance) {
                    modules[moduleId].instance.params[param] = toggleBtn.classList.contains('active') ? 1 : 0;
                }
            }
        });

        document.addEventListener('mousemove', e => {
            if (dragState) updatePreview(e);
            if (knobDrag) updateKnobDrag(e);
        });

        document.addEventListener('mouseup', e => {
            if (dragState) {
                const jack = e.target.closest('.jack');
                endDrag(jack, e);
            }
            if (knobDrag) endKnobDrag();
        });

        document.addEventListener('contextmenu', e => {
            if (e.target.closest('.jack')) e.preventDefault();
        });

        /* Redraw cables on resize */
        window.addEventListener('resize', () => cables.forEach(renderCable));

        /* Control buttons */
        document.getElementById('startButton').addEventListener('click', toggleAudio);
        document.getElementById('clearCables').addEventListener('click', clearAllCables);
        document.getElementById('copyPatch').addEventListener('click', copyPatchToClipboard);

        /* Initialize patch bank */
        initPatchBank();
    }

    function updateLeds(ledStates) {
        Object.entries(ledStates).forEach(([moduleId, leds]) => {
            Object.entries(leds).forEach(([ledId, value]) => {
                const el = document.getElementById(`led-${moduleId}-${ledId}`);
                if (el) {
                    el.classList.toggle('active', value > 0.1);
                }
            });
        });
    }

    function toggleAudio() {
        const btn = document.getElementById('startButton');

        if (isRunning) {
            isRunning = false;
            btn.textContent = '▶ Start';
            btn.classList.remove('active');

            /* Stop the engine */
            if (engine) {
                engine.stop();
                engine = null;
            }

            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            /* Clear instances */
            Object.keys(modules).forEach(id => modules[id].instance = null);
        } else {
            /* Create audio context and module instances */
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            Object.keys(modules).forEach(id => {
                const mod = modules[id];
                /* Create DSP instance using new module system */
                mod.instance = mod.def.createDSP({
                    sampleRate: audioCtx.sampleRate,
                    bufferSize: 512,
                    audioCtx: audioCtx
                });

                /* Execute custom render function if not already done */
                if (mod.el._customRender) {
                    const { render, content, toolkit } = mod.el._customRender;
                    render(content, {
                        instance: {
                            id: id,
                            type: mod.type,
                            def: mod.def,
                            dsp: mod.instance,
                            element: mod.el
                        },
                        toolkit,
                        onParamChange: (param, value) => {
                            mod.instance.params[param] = value;
                        }
                    });
                    delete mod.el._customRender;
                    /* Initialize knob rotations for custom-rendered knobs */
                    mod.el.querySelectorAll('.knob').forEach(updateKnobRotation);
                }

                /* Apply current knob values */
                document.querySelectorAll(`.knob[data-module="${id}"]`).forEach(knob => {
                    const param = knob.dataset.param;
                    const value = parseFloat(knob.dataset.value);
                    mod.instance.params[param] = value;
                });
                /* Apply current switch values */
                document.querySelectorAll(`.switch[data-module="${id}"]`).forEach(sw => {
                    const param = sw.dataset.param;
                    const isOn = sw.classList.contains('on');
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        mod.instance.params[match[1]][parseInt(match[2])] = isOn;
                    } else {
                        mod.instance.params[param] = isOn ? 1 : 0;
                    }
                });
                /* Apply current button bank values */
                document.querySelectorAll(`.button-bank[data-module="${id}"]`).forEach(bank => {
                    const param = bank.dataset.param;
                    const activeBtn = bank.querySelector('.octave-btn.active');
                    if (activeBtn) {
                        mod.instance.params[param] = parseInt(activeBtn.dataset.value);
                    }
                });
            });

            /* Create engine with modules and cables */
            engine = createAudioEngine({
                modules,
                cables: cables.map(c => ({
                    fromModule: c.fromModule,
                    fromPort: c.fromPort,
                    toModule: c.toModule,
                    toPort: c.toPort
                })),
                audioCtx,
                onLedUpdate: updateLeds
            });

            isRunning = true;
            btn.textContent = '⏹ Stop';
            btn.classList.add('active');
            engine.start();
        }
    }

    /* Start when DOM ready */
    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
