# Creating Modules

This guide covers everything you need to know to create custom modules for eurorack-js.

## Module Structure

Each module is a self-contained folder under `src/js/modules/`:

```
src/js/modules/mymodule/
└── index.js
```

The `index.js` exports a module definition object:

```javascript
export default {
    // Metadata
    id: 'mymodule',
    name: 'My Module',
    hp: 4,
    color: '#8b4513',
    category: 'utility',

    // DSP factory
    createDSP(options) { ... },

    // UI definition
    ui: { ... }
};
```

## Metadata Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier (lowercase, no spaces) |
| `name` | string | Display name shown in UI |
| `hp` | number | Panel width (2, 4, 6, or 8) |
| `color` | string | Header color (hex) |
| `category` | string | `source` \| `modulator` \| `utility` \| `effect` |

## The DSP Factory

The `createDSP` function returns a DSP instance:

```javascript
createDSP({ sampleRate = 44100, bufferSize = 512, audioCtx } = {}) {
    // Allocate output buffers (persisted across process calls)
    const out = new Float32Array(bufferSize);

    // Internal state
    let phase = 0;

    return {
        // Knob/switch values (set by UI)
        params: {
            frequency: 0.5,
            mode: 0
        },

        // Input buffers (connected by cables or defaults)
        inputs: {
            cv: new Float32Array(bufferSize),
            trigger: new Float32Array(bufferSize)
        },

        // Output buffers (read by downstream modules)
        outputs: { out },

        // LED brightness values (0-1, read by UI)
        leds: { active: 0 },

        // Called every audio frame
        process() {
            for (let i = 0; i < bufferSize; i++) {
                // DSP code here
                out[i] = Math.sin(phase) * 5;
                phase += 0.01;
            }
        },

        // Optional: reset state
        reset() {
            phase = 0;
            out.fill(0);
        }
    };
}
```

## UI Definition

The `ui` object declares the module's interface:

```javascript
ui: {
    leds: ['active', 'clip'],

    knobs: [
        { id: 'freq', label: 'Freq', param: 'frequency', min: 0, max: 1, default: 0.5 },
        { id: 'res', label: 'Res', param: 'resonance', min: 0, max: 1, default: 0.3 }
    ],

    switches: [
        { id: 'mode', label: 'Mode', param: 'mode', default: 0 }
    ],

    inputs: [
        { id: 'audio', label: 'In', port: 'audio', type: 'audio' },
        { id: 'cv', label: 'CV', port: 'cv', type: 'cv' }
    ],

    outputs: [
        { id: 'out', label: 'Out', port: 'out', type: 'audio' }
    ]
}
```

### Knob Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | string | Unique ID for this knob |
| `label` | string | Display label (short) |
| `param` | string | Maps to `params.{param}` |
| `min` | number | Minimum value |
| `max` | number | Maximum value |
| `default` | number | Initial value |

### Switch Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | string | Unique ID |
| `label` | string | Display label |
| `param` | string | Maps to `params.{param}` |
| `default` | number | Initial state (0 or 1) |

### Jack Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | string | Unique ID |
| `label` | string | Display label |
| `port` | string | Maps to `inputs.{port}` or `outputs.{port}` |
| `type` | string | Signal type (see below) |

### Port Types

| Type | Description | Typical Range |
|------|-------------|---------------|
| `audio` | Audio signals | ±5V |
| `cv` | Control voltage | 0-5V or ±5V |
| `gate` | On/off signals | 0V / 10V |
| `trigger` | Short pulses | 5-10V pulse |
| `buffer` | Generic buffer | varies |

## Voltage Standards

Eurorack uses voltage to represent everything:

### Audio Signals
- Range: **±5V** (bipolar)
- 0V = silence
- Generated by: VCO, noise, filters

### Control Voltage (CV)
- Range: **0-5V** (unipolar) or **±5V** (bipolar)
- Used for: modulation, parameter control
- Generated by: LFO, envelope, S&H

### Gates
- Off: **0V**
- On: **10V**
- Threshold: **≥1V** considered "on"
- Used for: note on/off, hold signals

### Triggers
- Short pulse: **5-10ms** at **5-10V**
- Threshold: **>2.5V** (rising edge)
- Used for: clock, reset, note events

### Pitch CV (1V/Octave)
- **0V** = base frequency
- **+1V** = one octave up (2x frequency)
- **+0.0833V** = one semitone up

```javascript
// V/Oct to frequency
const freq = baseFreq * Math.pow(2, vOct);

// With semitone offset
const freq = baseFreq * Math.pow(2, vOct + semitones/12);
```

## Common DSP Patterns

### Edge Detection (Triggers/Gates)

```javascript
let lastTrig = 0;

process() {
    for (let i = 0; i < bufferSize; i++) {
        const trig = this.inputs.trigger[i];

        // Rising edge detection
        if (trig >= 2.5 && lastTrig < 2.5) {
            // Trigger fired!
        }

        // IMPORTANT: Update AFTER the check
        lastTrig = trig;
    }
}
```

### Slew Limiting (Smoothing)

Use `createSlew` from the utils to smooth parameter changes and prevent clicks:

```javascript
import { createSlew } from '../utils/slew.js';

createDSP({ sampleRate, bufferSize }) {
    const slew = createSlew({ sampleRate, timeMs: 5 });

    return {
        process() {
            for (let i = 0; i < bufferSize; i++) {
                const smoothedCV = slew.process(this.inputs.cv[i]);
                // Use smoothedCV instead of raw CV
            }
        }
    };
}
```

### Phase Accumulator (Oscillators)

```javascript
let phase = 0;

process() {
    const freq = 440; // Hz
    const phaseInc = freq / sampleRate;

    for (let i = 0; i < bufferSize; i++) {
        // Generate waveforms from phase (0-1)
        const saw = phase * 2 - 1;           // -1 to +1
        const sine = Math.sin(phase * 2 * Math.PI);
        const square = phase < 0.5 ? 1 : -1;

        // Scale to ±5V
        out[i] = saw * 5;

        // Advance and wrap phase
        phase += phaseInc;
        if (phase >= 1) phase -= 1;
    }
}
```

### LED Metering

```javascript
process() {
    let peak = 0;

    for (let i = 0; i < bufferSize; i++) {
        out[i] = /* ... */;
        peak = Math.max(peak, Math.abs(out[i]));
    }

    // Scale to 0-1 range (assuming ±5V signal)
    this.leds.level = peak / 5;
}
```

### LED Decay (Peak Hold)

```javascript
createDSP({ sampleRate, bufferSize }) {
    // Decay constant for ~100ms hold
    const ledDecay = Math.exp(-1 / (sampleRate * 0.1) * bufferSize);

    return {
        leds: { peak: 0 },

        process() {
            let currentPeak = 0;

            for (let i = 0; i < bufferSize; i++) {
                currentPeak = Math.max(currentPeak, Math.abs(out[i]));
            }

            // Peak hold with decay
            this.leds.peak = Math.max(currentPeak / 5, this.leds.peak * ledDecay);
        }
    };
}
```

### Handling Unpatched Audio Inputs

Audio inputs should produce silence when disconnected. Use this pattern:

```javascript
createDSP({ bufferSize }) {
    const ownAudioIn = new Float32Array(bufferSize);

    return {
        inputs: {
            audio: ownAudioIn
        },

        clearAudioInputs() {
            ownAudioIn.fill(0);
            this.inputs.audio = ownAudioIn;
        },

        process() {
            // Use this.inputs.audio...

            // Reset if cable was connected then removed
            if (this.inputs.audio !== ownAudioIn) {
                ownAudioIn.fill(0);
                this.inputs.audio = ownAudioIn;
            }
        }
    };
}
```

## Complete Example: Simple VCA

```javascript
// src/js/modules/simplevca/index.js
import { clamp } from '../../utils/math.js';
import { createSlew } from '../../utils/slew.js';

export default {
    id: 'simplevca',
    name: 'VCA',
    hp: 2,
    color: '#4a4a8a',
    category: 'utility',

    createDSP({ sampleRate = 44100, bufferSize = 512 } = {}) {
        const out = new Float32Array(bufferSize);
        const ownAudioIn = new Float32Array(bufferSize);

        const cvSlew = createSlew({ sampleRate, timeMs: 5 });
        const ledDecay = Math.exp(-1 / (sampleRate * 0.1) * bufferSize);

        return {
            params: { gain: 1 },

            inputs: {
                audio: ownAudioIn,
                cv: new Float32Array(bufferSize).fill(5)
            },

            outputs: { out },

            leds: { level: 0 },

            clearAudioInputs() {
                ownAudioIn.fill(0);
                this.inputs.audio = ownAudioIn;
            },

            process() {
                const gain = clamp(this.params.gain, 0, 1);
                let peak = 0;

                for (let i = 0; i < bufferSize; i++) {
                    // Smooth CV to prevent clicks
                    const cv = cvSlew.process(this.inputs.cv[i]);
                    const cvGain = clamp(cv / 5, 0, 1);

                    // Apply both manual gain and CV
                    const sample = this.inputs.audio[i] * gain * cvGain;
                    out[i] = sample;

                    peak = Math.max(peak, Math.abs(sample));
                }

                // Update LED with peak hold
                this.leds.level = Math.max(peak / 5, this.leds.level * ledDecay);

                // Handle disconnected input
                if (this.inputs.audio !== ownAudioIn) {
                    ownAudioIn.fill(0);
                    this.inputs.audio = ownAudioIn;
                }
            },

            reset() {
                out.fill(0);
                this.leds.level = 0;
            }
        };
    },

    ui: {
        leds: ['level'],
        knobs: [
            { id: 'gain', label: 'Gain', param: 'gain', min: 0, max: 1, default: 0.8 }
        ],
        inputs: [
            { id: 'audio', label: 'In', port: 'audio', type: 'audio' },
            { id: 'cv', label: 'CV', port: 'cv', type: 'cv' }
        ],
        outputs: [
            { id: 'out', label: 'Out', port: 'out', type: 'audio' }
        ]
    }
};
```

## Registering Your Module

Add your module to the `loadModules()` function in `src/js/rack/registry.js`:

```javascript
export async function loadModules() {
    const moduleImports = await Promise.all([
        // ... existing modules
        import('../modules/mymodule/index.js'),  // Add your module here
    ]);
    // ...
}
```

Then add it to the rack order in `src/index.html` or your rack configuration.

## Testing Your Module

Create a test file at `tests/dsp/mymodule.test.js`:

```javascript
import { describe, it, expect, beforeEach } from 'vitest';
import myModule from '../../src/js/modules/mymodule/index.js';

const createMyModule = (options = {}) => myModule.createDSP(options);

describe('myModule', () => {
    let mod;

    beforeEach(() => {
        mod = createMyModule();
    });

    describe('initialization', () => {
        it('should have default params', () => {
            expect(mod.params.gain).toBe(1);
        });

        it('should create buffers', () => {
            expect(mod.outputs.out).toBeInstanceOf(Float32Array);
            expect(mod.outputs.out.length).toBe(512);
        });
    });

    describe('processing', () => {
        it('should not produce NaN', () => {
            mod.process();
            expect(mod.outputs.out.every(v => !isNaN(v))).toBe(true);
        });

        it('should stay within voltage range', () => {
            // Fill input with signal
            mod.inputs.audio.fill(5);
            mod.process();

            const max = Math.max(...mod.outputs.out);
            const min = Math.min(...mod.outputs.out);

            expect(max).toBeLessThanOrEqual(5);
            expect(min).toBeGreaterThanOrEqual(-5);
        });
    });
});
```

Run tests with:

```bash
npm test
```

## Tips

1. **Allocate buffers once** in `createDSP`, not in `process()`
2. **Use slew** for any CV that controls amplitude or frequency
3. **Clamp inputs** to prevent NaN and Infinity
4. **Update LEDs** in `process()` for real-time feedback
5. **Test edge cases**: zero inputs, maximum inputs, rapid parameter changes
6. **Follow voltage standards** for interoperability with other modules

## Debugging

Common issues:

| Problem | Cause | Fix |
|---------|-------|-----|
| NaN in output | Division by zero | Add guards: `x / (y \|\| 0.001)` |
| Clicks/pops | Sudden value changes | Use `createSlew()` |
| No sound | Wrong voltage range | Check ±5V for audio |
| Trigger not firing | Wrong threshold | Use `>= 2.5` for rising edge |
| DC offset | Unbalanced waveform | Center around 0V |
