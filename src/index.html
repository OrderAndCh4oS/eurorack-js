<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2HP Mini‑Rack – Interactive Patcher</title>
    <style>
        :root {
            --hp: 12px;
            --module-height: 380px;
            --jack-size: 24px;
            --knob-size: 32px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        .rack {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 20px;
            display: flex;
            gap: 4px;
            border-top: 12px solid #444;
            border-bottom: 12px solid #333;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .module {
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border: 1px solid #555;
            border-radius: 3px;
            height: var(--module-height);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .module-2hp { width: calc(var(--hp) * 6); }
        .module-4hp { width: calc(var(--hp) * 12); }
        .module-8hp { width: calc(var(--hp) * 20); }

        .module-label {
            font-size: 9px;
            font-weight: bold;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .module-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 100%;
        }

        /* Knobs */
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .knob {
            width: var(--knob-size);
            height: var(--knob-size);
            background: linear-gradient(145deg, #555, #333);
            border-radius: 50%;
            border: 2px solid #222;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.1);
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 10px;
            background: #fff;
            border-radius: 1px;
            top: 4px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
            box-shadow: 0 0 3px rgba(255,255,255,0.5);
        }

        .knob:hover {
            background: linear-gradient(145deg, #666, #444);
        }

        .knob-label {
            font-size: 7px;
            color: #999;
            text-transform: uppercase;
        }

        /* Jacks */
        .jack-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .jack {
            width: var(--jack-size);
            height: var(--jack-size);
            background: radial-gradient(circle at 30% 30%, #222, #111);
            border-radius: 50%;
            border: 2px solid #444;
            position: relative;
            cursor: crosshair;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8);
        }

        .jack::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #111;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #333;
        }

        .jack.output {
            border-color: #c44;
        }

        .jack.input {
            border-color: #4a4;
        }

        .jack:hover {
            border-color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8), 0 0 8px rgba(255,255,255,0.3);
        }

        .jack.connected::after {
            background: #666;
        }

        .jack-label {
            font-size: 6px;
            color: #888;
            text-transform: uppercase;
        }

        /* Jack rows */
        .jack-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Compact elements for wider modules */
        .module-8hp .jack-row {
            gap: 2px;
        }

        .module-8hp .jack {
            width: 20px;
            height: 20px;
        }

        .module-8hp .switch {
            width: 14px;
            height: 20px;
        }

        .module-8hp .switch::after {
            width: 10px;
            height: 8px;
            left: 1px;
            top: 2px;
        }

        .module-8hp .switch.on::after {
            top: 9px;
        }

        .module-8hp .knob {
            width: 28px;
            height: 28px;
        }

        .module-8hp .knob::after {
            height: 8px;
            top: 3px;
        }

        /* LEDs */
        .led {
            width: 6px;
            height: 6px;
            background: #300;
            border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        .led.active {
            background: #f44;
            box-shadow: 0 0 8px #f44, inset 0 1px 2px rgba(255,255,255,0.3);
        }

        .led.green { background: #030; }
        .led.green.active { background: #4f4; box-shadow: 0 0 8px #4f4; }

        /* Switches */
        .switch {
            width: 16px;
            height: 24px;
            background: linear-gradient(to bottom, #444, #333);
            border-radius: 3px;
            border: 1px solid #555;
            cursor: pointer;
            position: relative;
        }

        .switch::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 10px;
            background: linear-gradient(to bottom, #888, #666);
            border-radius: 2px;
            left: 1px;
            top: 2px;
            transition: top 0.1s;
        }

        .switch.on::after {
            top: 11px;
        }

        /* Button bank (octave select) */
        .button-bank {
            display: flex;
            gap: 2px;
            padding: 2px 0;
        }

        .octave-btn {
            width: 14px;
            height: 16px;
            font-size: 7px;
            background: linear-gradient(to bottom, #444, #333);
            border: 1px solid #555;
            border-radius: 2px;
            color: #999;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .octave-btn:hover {
            background: linear-gradient(to bottom, #555, #444);
        }

        .octave-btn.active {
            background: linear-gradient(to bottom, #8b5cf6, #6d28d9);
            border-color: #a78bfa;
            color: #fff;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.5);
        }

        /* Cable SVG overlay */
        #cable-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .cable {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
        }

        .cable-preview {
            opacity: 0.6;
            stroke-dasharray: 8 4;
        }

        /* Spacer */
        .spacer {
            flex: 1;
        }

        /* Section dividers */
        .section-label {
            font-size: 6px;
            color: #666;
            width: 100%;
            text-align: center;
            border-top: 1px solid #444;
            padding-top: 4px;
            margin-top: 2px;
        }

        /* Toolbar */
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
            z-index: 200;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: #444;
        }

        .toolbar-spacer {
            flex: 1;
        }

        #toolbar select {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            cursor: pointer;
            min-width: 140px;
        }

        #toolbar select:hover {
            background: #444;
        }

        #toolbar input[type="text"] {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 110px;
        }

        #toolbar input[type="text"]::placeholder {
            color: #666;
        }

        #toolbar button {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #444;
            color: #fff;
            transition: background 0.2s;
            white-space: nowrap;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.primary {
            background: #2a5a2a;
        }

        #toolbar button.primary:hover {
            background: #3a7a3a;
        }

        #toolbar button.danger {
            background: #5a2a2a;
        }

        #toolbar button.danger:hover {
            background: #7a3a3a;
        }

        #toolbar button.active {
            background: #4a4;
        }

        .toolbar-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Offset rack for toolbar */
        .rack {
            margin-top: 48px;
        }
    </style>
</head>
<body>
<div id="toolbar">
    <div class="toolbar-section">
        <button id="startButton">▶ Start</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <span class="toolbar-label">Patches</span>
        <select id="patchSelect">
            <option value="">-- Select --</option>
        </select>
        <button id="loadPatch">Load</button>
        <button id="deletePatch" class="danger">Del</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <input type="text" id="patchName" placeholder="New patch...">
        <button id="savePatch" class="primary">Save</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button id="copyPatch">Copy</button>
    </div>
    <div class="toolbar-spacer"></div>
    <div class="toolbar-section">
        <button id="clearCables">Clear Cables</button>
    </div>
</div>

<svg id="cable-svg"></svg>

<div class="rack" id="rack">
    <!-- Modules will be rendered by JavaScript -->
</div>

<script type="module">
    /* =============================================================
     * Import modular definitions
     * =========================================================== */
    import { createModuleDefs, MODULE_ORDER } from './js/config/module-defs.js';
    import { CABLE_COLORS } from './js/config/constants.js';
    import { FACTORY_PATCHES } from './js/config/factory-patches.js';
    import { adjustColor } from './js/utils/color.js';
    import { createAudioEngine } from './js/audio/engine.js';
    import { createCablePath, getJackCenter } from './js/cables/cable-manager.js';

    /* =============================================================
     * Interactive Patcher System
     * -------------------------------------------------------------
     * Renders modules with knobs and jacks, allows cable patching
     * =========================================================== */

    /* Constants imported from js/config/constants.js */
    let colorIndex = 0;

    /* State */
    let audioCtx = null;
    let engine = null;
    let isRunning = false;
    let modules = {};
    let cables = [];
    let dragState = null;


    /* Module definitions imported from js/config/module-defs.js */
    let MODULE_DEFS = null;  // Initialized in init() with audioCtx


    /* =============================================================
     * UI Rendering
     * =========================================================== */
    function renderModule(type, id) {
        const def = MODULE_DEFS[type];
        const el = document.createElement('div');
        el.className = `module module-${def.hp}hp`;
        el.id = `module-${id}`;
        el.style.background = `linear-gradient(to bottom, ${def.color}, ${adjustColor(def.color, -30)})`;

        let html = `<div class="module-label">${def.name}</div><div class="module-content">`;

        /* LEDs */
        if (def.leds) {
            html += '<div class="jack-row">';
            def.leds.forEach(led => {
                html += `<div class="led green" id="led-${id}-${led}"></div>`;
            });
            html += '</div>';
        }

        /* Knobs - render in a row if more than 2 */
        if (def.knobs.length > 2) {
            html += '<div class="jack-row">';
        }
        def.knobs.forEach(knob => {
            html += `
                <div class="knob-container">
                    <div class="knob" id="knob-${id}-${knob.id}"
                         data-module="${id}" data-param="${knob.param}"
                         data-min="${knob.min}" data-max="${knob.max}"
                         data-value="${knob.default}" data-step="${knob.step || 0}"></div>
                    <div class="knob-label">${knob.label}</div>
                </div>`;
        });
        if (def.knobs.length > 2) {
            html += '</div>';
        }

        /* Switches - render in a row */
        if (def.switches && def.switches.length > 0) {
            html += '<div class="jack-row">';
            def.switches.forEach(sw => {
                html += `
                    <div class="knob-container">
                        <div class="switch ${sw.default ? 'on' : ''}" id="switch-${id}-${sw.id}"
                             data-module="${id}" data-param="${sw.param}"></div>
                        <div class="knob-label">${sw.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Button banks (octave select) */
        if (def.buttons && def.buttons.length > 0) {
            def.buttons.forEach(btnGroup => {
                html += `<div class="section-label">${btnGroup.label}</div><div class="button-bank" data-module="${id}" data-param="${btnGroup.param}">`;
                btnGroup.values.forEach((val, idx) => {
                    const isActive = val === btnGroup.default;
                    html += `<button class="octave-btn${isActive ? ' active' : ''}" data-value="${val}">${val > 0 ? '+' + val : val}</button>`;
                });
                html += '</div>';
            });
        }

        html += '<div class="spacer"></div>';

        /* Outputs */
        if (def.outputs.length > 0) {
            html += '<div class="section-label">Out</div><div class="jack-row">';
            def.outputs.forEach(out => {
                html += `
                    <div class="jack-container">
                        <div class="jack output" id="jack-${id}-${out.id}"
                             data-module="${id}" data-port="${out.output}" data-dir="output" data-type="${out.type}"></div>
                        <div class="jack-label">${out.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Inputs - group by type for larger modules */
        if (def.inputs.length > 0) {
            if (def.inputs.length > 4) {
                /* Split inputs into groups (CV and triggers) */
                const cvInputs = def.inputs.filter(i => i.id.startsWith('cv'));
                const trigInputs = def.inputs.filter(i => i.id.startsWith('trig'));
                const otherInputs = def.inputs.filter(i => !i.id.startsWith('cv') && !i.id.startsWith('trig'));

                if (cvInputs.length > 0) {
                    html += '<div class="section-label">CV In</div><div class="jack-row">';
                    cvInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.input}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (trigInputs.length > 0) {
                    html += '<div class="section-label">Trig In</div><div class="jack-row">';
                    trigInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.input}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (otherInputs.length > 0) {
                    html += '<div class="section-label">In</div><div class="jack-row">';
                    otherInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.input}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
            } else {
                html += '<div class="section-label">In</div><div class="jack-row">';
                def.inputs.forEach(inp => {
                    html += `
                        <div class="jack-container">
                            <div class="jack input" id="jack-${id}-${inp.id}"
                                 data-module="${id}" data-port="${inp.input}" data-dir="input" data-type="${inp.type}"></div>
                            <div class="jack-label">${inp.label}</div>
                        </div>`;
                });
                html += '</div>';
            }
        }

        html += '</div>';
        el.innerHTML = html;
        return el;
    }

    function updateKnobRotation(knobEl) {
        const min = parseFloat(knobEl.dataset.min);
        const max = parseFloat(knobEl.dataset.max);
        const value = parseFloat(knobEl.dataset.value);
        const rotation = -135 + ((value - min) / (max - min)) * 270;
        knobEl.style.setProperty('--rotation', `${rotation}deg`);
        const indicator = knobEl.querySelector('::after') || knobEl;
        knobEl.style.transform = `rotate(${rotation}deg)`;
    }

    /* =============================================================
     * Cable System
     * =========================================================== */
    const svgNS = 'http://www.w3.org/2000/svg';
    const cableSvg = document.getElementById('cable-svg');

    function renderCable(cable) {
        const from = getJackCenter(cable.fromEl);
        const to = getJackCenter(cable.toEl);
        cable.pathEl.setAttribute('d', createCablePath(from.x, from.y, to.x, to.y));
    }

    function addCable(fromJack, toJack, color = null) {
        const path = document.createElementNS(svgNS, 'path');
        path.classList.add('cable');
        /* Use provided color or get next color from palette */
        path.style.stroke = color || CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
        cableSvg.appendChild(path);

        const cable = {
            fromEl: fromJack,
            toEl: toJack,
            pathEl: path,
            fromModule: fromJack.dataset.module,
            fromPort: fromJack.dataset.port,
            toModule: toJack.dataset.module,
            toPort: toJack.dataset.port,
            type: fromJack.dataset.type
        };

        cables.push(cable);
        fromJack.classList.add('connected');
        toJack.classList.add('connected');
        renderCable(cable);

        /* Update engine with new cable state */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }

        return cable;
    }

    function removeCable(cable) {
        cable.pathEl.remove();
        cable.fromEl.classList.remove('connected');
        cable.toEl.classList.remove('connected');
        cables = cables.filter(c => c !== cable);

        /* Update engine with new cable state - handles audio input clearing */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }
    }

    function clearAllCables() {
        cables.forEach(c => {
            c.pathEl.remove();
            c.fromEl.classList.remove('connected');
            c.toEl.classList.remove('connected');
        });
        cables = [];

        /* Update engine with empty cables - handles audio input clearing */
        if (engine) {
            engine.setCables([]);
        }
    }

    /* Preview cable while dragging */
    let previewPath = null;

    function startDrag(jackEl, e) {
        /* Check if this jack has an existing cable connected */
        const existingCable = cables.find(c => c.fromEl === jackEl || c.toEl === jackEl);

        if (existingCable) {
            /* Detach the cable from this jack, drag from the other end */
            const isFromEnd = existingCable.fromEl === jackEl;
            const anchorJack = isFromEnd ? existingCable.toEl : existingCable.fromEl;
            const cableColor = existingCable.pathEl.style.stroke;

            /* Remove the existing cable */
            removeCable(existingCable);

            /* Start dragging from the anchor (the other end) */
            dragState = {
                startJack: anchorJack,
                startDir: anchorJack.dataset.dir,
                reconnecting: true
            };

            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = cableColor;
            cableSvg.appendChild(previewPath);
        } else {
            /* No existing cable - start new connection */
            dragState = {
                startJack: jackEl,
                startDir: jackEl.dataset.dir,
                reconnecting: false
            };
            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
            cableSvg.appendChild(previewPath);
        }
        updatePreview(e);
    }

    function updatePreview(e) {
        if (!dragState || !previewPath) return;
        const start = getJackCenter(dragState.startJack);
        const end = {x: e.clientX, y: e.clientY};
        previewPath.setAttribute('d', createCablePath(start.x, start.y, end.x, end.y));
    }

    function endDrag(targetJack) {
        if (!dragState) return;

        const cableColor = previewPath ? previewPath.style.stroke : CABLE_COLORS[colorIndex % CABLE_COLORS.length];

        if (previewPath) {
            previewPath.remove();
            previewPath = null;
        }

        let connected = false;

        if (targetJack && targetJack !== dragState.startJack) {
            const startDir = dragState.startDir;
            const endDir = targetJack.dataset.dir;

            /* Must connect output to input (different directions) */
            if (startDir !== endDir) {
                const fromJack = startDir === 'output' ? dragState.startJack : targetJack;
                const toJack = startDir === 'input' ? dragState.startJack : targetJack;

                /* Remove existing cable to this input */
                const existing = cables.find(c => c.toEl === toJack);
                if (existing) removeCable(existing);

                addCable(fromJack, toJack, cableColor);
                connected = true;
            }
        }

        /* If reconnecting and dropped on invalid target, cable is removed (already done in startDrag) */
        /* If new cable and dropped on invalid target, nothing happens */

        dragState = null;
    }

    /* =============================================================
     * Knob Interaction
     * =========================================================== */
    let knobDrag = null;

    function startKnobDrag(knobEl, e) {
        knobDrag = {
            knob: knobEl,
            startY: e.clientY,
            startValue: parseFloat(knobEl.dataset.value)
        };
    }

    function updateKnobDrag(e) {
        if (!knobDrag) return;
        const knob = knobDrag.knob;
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const step = parseFloat(knob.dataset.step) || 0;
        const range = max - min;
        const dy = knobDrag.startY - e.clientY;
        let newValue = knobDrag.startValue + (dy / 150) * range;

        if (step > 0) {
            newValue = Math.round(newValue / step) * step;
        }
        newValue = Math.max(min, Math.min(max, newValue));

        knob.dataset.value = newValue;
        updateKnobRotation(knob);

        /* Update module param */
        const moduleId = knob.dataset.module;
        const param = knob.dataset.param;
        if (modules[moduleId] && modules[moduleId].instance) {
            modules[moduleId].instance.params[param] = newValue;
        }
    }

    function endKnobDrag() {
        knobDrag = null;
    }

    /* =============================================================
     * Patch Bank System
     * -------------------------------------------------------------
     * Save and load patches to/from localStorage
     * =========================================================== */
    const PATCH_STORAGE_KEY = 'eurorack-patches';


    function getPatchList() {
        try {
            const data = localStorage.getItem(PATCH_STORAGE_KEY);
            const userPatches = data ? JSON.parse(data) : {};
            /* Merge factory patches with user patches (user patches take precedence) */
            return { ...FACTORY_PATCHES, ...userPatches };
        } catch (e) {
            console.error('Error loading patches:', e);
            return { ...FACTORY_PATCHES };
        }
    }

    function savePatchList(patches) {
        try {
            localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(patches));
        } catch (e) {
            console.error('Error saving patches:', e);
        }
    }

    function serializeCurrentState() {
        const state = {
            knobs: {},
            switches: {},
            buttons: {},
            cables: []
        };

        /* Serialize all knob values */
        document.querySelectorAll('.knob').forEach(knob => {
            const moduleId = knob.dataset.module;
            const param = knob.dataset.param;
            const value = parseFloat(knob.dataset.value);
            if (!state.knobs[moduleId]) state.knobs[moduleId] = {};
            state.knobs[moduleId][param] = value;
        });

        /* Serialize all switch states */
        document.querySelectorAll('.switch').forEach(sw => {
            const moduleId = sw.dataset.module;
            const param = sw.dataset.param;
            const isOn = sw.classList.contains('on');
            if (!state.switches[moduleId]) state.switches[moduleId] = {};
            state.switches[moduleId][param] = isOn;
        });

        /* Serialize all button bank states */
        document.querySelectorAll('.button-bank').forEach(bank => {
            const moduleId = bank.dataset.module;
            const param = bank.dataset.param;
            const activeBtn = bank.querySelector('.octave-btn.active');
            const value = activeBtn ? parseInt(activeBtn.dataset.value) : 0;
            if (!state.buttons[moduleId]) state.buttons[moduleId] = {};
            state.buttons[moduleId][param] = value;
        });

        /* Serialize cable connections */
        cables.forEach(cable => {
            state.cables.push({
                fromModule: cable.fromModule,
                fromPort: cable.fromPort,
                toModule: cable.toModule,
                toPort: cable.toPort
            });
        });

        return state;
    }

    function applyPatchState(state) {
        /* Clear existing cables */
        clearAllCables();

        /* Apply knob values */
        if (state.knobs) {
            Object.entries(state.knobs).forEach(([moduleId, params]) => {
                Object.entries(params).forEach(([param, value]) => {
                    const knob = document.querySelector(`.knob[data-module="${moduleId}"][data-param="${param}"]`);
                    if (knob) {
                        knob.dataset.value = value;
                        updateKnobRotation(knob);
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    }
                });
            });
        }

        /* Apply switch states */
        if (state.switches) {
            Object.entries(state.switches).forEach(([moduleId, params]) => {
                Object.entries(params).forEach(([param, isOn]) => {
                    const sw = document.querySelector(`.switch[data-module="${moduleId}"][data-param="${param}"]`);
                    if (sw) {
                        sw.classList.toggle('on', isOn);
                        if (modules[moduleId]?.instance) {
                            if (param.includes('[')) {
                                const match = param.match(/(\w+)\[(\d+)\]/);
                                if (match) {
                                    modules[moduleId].instance.params[match[1]][parseInt(match[2])] = isOn;
                                }
                            } else {
                                modules[moduleId].instance.params[param] = isOn ? 1 : 0;
                            }
                        }
                    }
                });
            });
        }

        /* Apply button bank states */
        if (state.buttons) {
            Object.entries(state.buttons).forEach(([moduleId, params]) => {
                Object.entries(params).forEach(([param, value]) => {
                    const bank = document.querySelector(`.button-bank[data-module="${moduleId}"][data-param="${param}"]`);
                    if (bank) {
                        bank.querySelectorAll('.octave-btn').forEach(btn => {
                            btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
                        });
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    }
                });
            });
        }

        /* Apply cable connections */
        if (state.cables) {
            state.cables.forEach(conn => {
                /* Find jacks by module, port, and direction (output→input) */
                const fromJack = document.querySelector(`.jack.output[data-module="${conn.fromModule}"][data-port="${conn.fromPort}"]`);
                const toJack = document.querySelector(`.jack.input[data-module="${conn.toModule}"][data-port="${conn.toPort}"]`);
                if (fromJack && toJack) {
                    addCable(fromJack, toJack);
                }
            });
        }
    }

    function savePatch(name) {
        if (!name || !name.trim()) {
            alert('Please enter a patch name');
            return false;
        }
        name = name.trim();

        const patches = getPatchList();
        patches[name] = {
            name: name,
            created: new Date().toISOString(),
            state: serializeCurrentState()
        };

        savePatchList(patches);
        updatePatchSelect();
        return true;
    }

    function loadPatch(name) {
        const patches = getPatchList();
        if (!patches[name]) {
            alert('Patch not found');
            return false;
        }

        applyPatchState(patches[name].state);
        return true;
    }

    function deletePatch(name) {
        if (!name) return false;

        /* Cannot delete factory patches */
        if (FACTORY_PATCHES[name]) {
            alert('Cannot delete factory patches');
            return false;
        }

        const patches = getPatchList();
        if (!patches[name]) return false;

        if (!confirm(`Delete patch "${name}"?`)) return false;

        /* Only delete from user patches in localStorage */
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        delete userPatches[name];
        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(userPatches));
        updatePatchSelect();
        return true;
    }

    function copyPatchToClipboard() {
        const state = serializeCurrentState();
        const json = JSON.stringify(state, null, 4);
        navigator.clipboard.writeText(json).then(() => {
            const btn = document.getElementById('copyPatch');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = originalText, 1500);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    }

    function updatePatchSelect() {
        const select = document.getElementById('patchSelect');
        const patches = getPatchList();

        /* Clear existing options except the first placeholder */
        while (select.options.length > 1) {
            select.remove(1);
        }

        /* Separate factory and user patches */
        const factoryNames = Object.keys(FACTORY_PATCHES).sort();
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        const userNames = Object.keys(userPatches).sort();

        /* Add factory patches group */
        if (factoryNames.length > 0) {
            const factoryGroup = document.createElement('optgroup');
            factoryGroup.label = 'Factory Patches';
            factoryNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                factoryGroup.appendChild(option);
            });
            select.appendChild(factoryGroup);
        }

        /* Add user patches group */
        if (userNames.length > 0) {
            const userGroup = document.createElement('optgroup');
            userGroup.label = 'My Patches';
            userNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                userGroup.appendChild(option);
            });
            select.appendChild(userGroup);
        }
    }

    function initPatchBank() {
        /* Update patch list dropdown */
        updatePatchSelect();

        /* Save button */
        document.getElementById('savePatch').addEventListener('click', () => {
            const nameInput = document.getElementById('patchName');
            if (savePatch(nameInput.value)) {
                /* Select the newly saved patch */
                document.getElementById('patchSelect').value = nameInput.value.trim();
                nameInput.value = '';
            }
        });

        /* Load button */
        document.getElementById('loadPatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });

        /* Delete button */
        document.getElementById('deletePatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                deletePatch(select.value);
                select.value = '';
            }
        });

        /* Allow Enter key to save */
        document.getElementById('patchName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('savePatch').click();
            }
        });

        /* Double-click on select to load */
        document.getElementById('patchSelect').addEventListener('dblclick', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });
    }

    /* =============================================================
     * Initialization
     * =========================================================== */
    function init() {
        /* Initialize module definitions from imported config */
        MODULE_DEFS = createModuleDefs();

        const rack = document.getElementById('rack');

        /* Create modules using imported MODULE_ORDER */
        MODULE_ORDER.forEach(type => {
            const def = MODULE_DEFS[type];
            const el = renderModule(type, type);
            rack.appendChild(el);
            modules[type] = {def, el, instance: null};
        });

        /* Initialize knob rotations */
        document.querySelectorAll('.knob').forEach(updateKnobRotation);

        /* Event listeners */
        document.addEventListener('mousedown', e => {
            const jack = e.target.closest('.jack');
            const knob = e.target.closest('.knob');
            const sw = e.target.closest('.switch');
            const octBtn = e.target.closest('.octave-btn');

            if (jack) {
                e.preventDefault();
                /* Right-click to remove cables */
                if (e.button === 2) {
                    const cable = cables.find(c => c.fromEl === jack || c.toEl === jack);
                    if (cable) removeCable(cable);
                } else {
                    startDrag(jack, e);
                }
            } else if (knob) {
                e.preventDefault();
                startKnobDrag(knob, e);
            } else if (sw) {
                e.preventDefault();
                sw.classList.toggle('on');
                const moduleId = sw.dataset.module;
                const param = sw.dataset.param;
                if (modules[moduleId]?.instance) {
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        modules[moduleId].instance.params[match[1]][parseInt(match[2])] = sw.classList.contains('on');
                    } else {
                        modules[moduleId].instance.params[param] = sw.classList.contains('on') ? 1 : 0;
                    }
                }
            } else if (octBtn) {
                e.preventDefault();
                const bank = octBtn.closest('.button-bank');
                const moduleId = bank.dataset.module;
                const param = bank.dataset.param;
                const value = parseInt(octBtn.dataset.value);
                /* Toggle active state */
                bank.querySelectorAll('.octave-btn').forEach(b => b.classList.remove('active'));
                octBtn.classList.add('active');
                /* Update module param */
                if (modules[moduleId]?.instance) {
                    modules[moduleId].instance.params[param] = value;
                }
            }
        });

        document.addEventListener('mousemove', e => {
            if (dragState) updatePreview(e);
            if (knobDrag) updateKnobDrag(e);
        });

        document.addEventListener('mouseup', e => {
            if (dragState) {
                const jack = e.target.closest('.jack');
                endDrag(jack);
            }
            if (knobDrag) endKnobDrag();
        });

        document.addEventListener('contextmenu', e => {
            if (e.target.closest('.jack')) e.preventDefault();
        });

        /* Redraw cables on resize */
        window.addEventListener('resize', () => cables.forEach(renderCable));

        /* Control buttons */
        document.getElementById('startButton').addEventListener('click', toggleAudio);
        document.getElementById('clearCables').addEventListener('click', clearAllCables);
        document.getElementById('copyPatch').addEventListener('click', copyPatchToClipboard);

        /* Initialize patch bank */
        initPatchBank();
    }

    function updateLeds(ledStates) {
        Object.entries(ledStates).forEach(([moduleId, leds]) => {
            Object.entries(leds).forEach(([ledId, value]) => {
                const el = document.getElementById(`led-${moduleId}-${ledId}`);
                if (el) {
                    el.classList.toggle('active', value > 0.1);
                }
            });
        });
    }

    function toggleAudio() {
        const btn = document.getElementById('startButton');

        if (isRunning) {
            isRunning = false;
            btn.textContent = '▶ Start';
            btn.classList.remove('active');

            /* Stop the engine */
            if (engine) {
                engine.stop();
                engine = null;
            }

            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            /* Clear instances */
            Object.keys(modules).forEach(id => modules[id].instance = null);
        } else {
            /* Create audio context and module instances */
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            Object.keys(modules).forEach(id => {
                /* Pass audioCtx to modules that need it (like 'out') */
                modules[id].instance = modules[id].def.create(audioCtx);
                /* Apply current knob values */
                document.querySelectorAll(`.knob[data-module="${id}"]`).forEach(knob => {
                    const param = knob.dataset.param;
                    const value = parseFloat(knob.dataset.value);
                    modules[id].instance.params[param] = value;
                });
                /* Apply current switch values */
                document.querySelectorAll(`.switch[data-module="${id}"]`).forEach(sw => {
                    const param = sw.dataset.param;
                    const isOn = sw.classList.contains('on');
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        modules[id].instance.params[match[1]][parseInt(match[2])] = isOn;
                    } else {
                        modules[id].instance.params[param] = isOn ? 1 : 0;
                    }
                });
                /* Apply current button bank values */
                document.querySelectorAll(`.button-bank[data-module="${id}"]`).forEach(bank => {
                    const param = bank.dataset.param;
                    const activeBtn = bank.querySelector('.octave-btn.active');
                    if (activeBtn) {
                        modules[id].instance.params[param] = parseInt(activeBtn.dataset.value);
                    }
                });
            });

            /* Create engine with modules and cables */
            engine = createAudioEngine({
                modules,
                cables: cables.map(c => ({
                    fromModule: c.fromModule,
                    fromPort: c.fromPort,
                    toModule: c.toModule,
                    toPort: c.toPort
                })),
                audioCtx,
                onLedUpdate: updateLeds
            });

            isRunning = true;
            btn.textContent = '⏹ Stop';
            btn.classList.add('active');
            engine.start();
        }
    }

    /* Start when DOM ready */
    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
