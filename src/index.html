<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2HP Mini‑Rack – Interactive Patcher</title>
    <style>
        :root {
            --hp: 12px;
            --module-height: 380px;
            --jack-size: 24px;
            --knob-size: 32px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        .rack {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 20px;
            display: flex;
            gap: 4px;
            border-top: 12px solid #444;
            border-bottom: 12px solid #333;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .module {
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border: 1px solid #555;
            border-radius: 3px;
            height: var(--module-height);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .module-2hp { width: calc(var(--hp) * 6); }
        .module-4hp { width: calc(var(--hp) * 12); }
        .module-8hp { width: calc(var(--hp) * 20); }

        .module-label {
            font-size: 9px;
            font-weight: bold;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .module-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 100%;
        }

        /* Knobs */
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .knob {
            width: var(--knob-size);
            height: var(--knob-size);
            background: linear-gradient(145deg, #555, #333);
            border-radius: 50%;
            border: 2px solid #222;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.1);
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 10px;
            background: #fff;
            border-radius: 1px;
            top: 4px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
            box-shadow: 0 0 3px rgba(255,255,255,0.5);
        }

        .knob:hover {
            background: linear-gradient(145deg, #666, #444);
        }

        .knob-label {
            font-size: 7px;
            color: #999;
            text-transform: uppercase;
        }

        /* Jacks */
        .jack-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .jack {
            width: var(--jack-size);
            height: var(--jack-size);
            background: radial-gradient(circle at 30% 30%, #222, #111);
            border-radius: 50%;
            border: 2px solid #444;
            position: relative;
            cursor: crosshair;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8);
        }

        .jack::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #111;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #333;
        }

        .jack.output {
            border-color: #c44;
        }

        .jack.input {
            border-color: #4a4;
        }

        .jack:hover {
            border-color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8), 0 0 8px rgba(255,255,255,0.3);
        }

        .jack.connected::after {
            background: #666;
        }

        .jack-label {
            font-size: 6px;
            color: #888;
            text-transform: uppercase;
        }

        /* Jack rows */
        .jack-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Compact elements for wider modules */
        .module-8hp .jack-row {
            gap: 2px;
        }

        .module-8hp .jack {
            width: 20px;
            height: 20px;
        }

        .module-8hp .switch {
            width: 14px;
            height: 20px;
        }

        .module-8hp .switch::after {
            width: 10px;
            height: 8px;
            left: 1px;
            top: 2px;
        }

        .module-8hp .switch.on::after {
            top: 9px;
        }

        .module-8hp .knob {
            width: 28px;
            height: 28px;
        }

        .module-8hp .knob::after {
            height: 8px;
            top: 3px;
        }

        /* LEDs */
        .led {
            width: 6px;
            height: 6px;
            background: #300;
            border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        .led.active {
            background: #f44;
            box-shadow: 0 0 8px #f44, inset 0 1px 2px rgba(255,255,255,0.3);
        }

        .led.green { background: #030; }
        .led.green.active { background: #4f4; box-shadow: 0 0 8px #4f4; }

        /* Switches */
        .switch {
            width: 16px;
            height: 24px;
            background: linear-gradient(to bottom, #444, #333);
            border-radius: 3px;
            border: 1px solid #555;
            cursor: pointer;
            position: relative;
        }

        .switch::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 10px;
            background: linear-gradient(to bottom, #888, #666);
            border-radius: 2px;
            left: 1px;
            top: 2px;
            transition: top 0.1s;
        }

        .switch.on::after {
            top: 11px;
        }

        /* Button bank (octave select) */
        .button-bank {
            display: flex;
            gap: 2px;
            padding: 2px 0;
        }

        .octave-btn {
            width: 14px;
            height: 16px;
            font-size: 7px;
            background: linear-gradient(to bottom, #444, #333);
            border: 1px solid #555;
            border-radius: 2px;
            color: #999;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .octave-btn:hover {
            background: linear-gradient(to bottom, #555, #444);
        }

        .octave-btn.active {
            background: linear-gradient(to bottom, #8b5cf6, #6d28d9);
            border-color: #a78bfa;
            color: #fff;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.5);
        }

        /* Cable SVG overlay */
        #cable-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .cable {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
        }

        .cable-preview {
            opacity: 0.6;
            stroke-dasharray: 8 4;
        }

        /* Spacer */
        .spacer {
            flex: 1;
        }

        /* Section dividers */
        .section-label {
            font-size: 6px;
            color: #666;
            width: 100%;
            text-align: center;
            border-top: 1px solid #444;
            padding-top: 4px;
            margin-top: 2px;
        }

        /* Toolbar */
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
            z-index: 200;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: #444;
        }

        .toolbar-spacer {
            flex: 1;
        }

        #toolbar select {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            cursor: pointer;
            min-width: 140px;
        }

        #toolbar select:hover {
            background: #444;
        }

        #toolbar input[type="text"] {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 110px;
        }

        #toolbar input[type="text"]::placeholder {
            color: #666;
        }

        #toolbar button {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #444;
            color: #fff;
            transition: background 0.2s;
            white-space: nowrap;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.primary {
            background: #2a5a2a;
        }

        #toolbar button.primary:hover {
            background: #3a7a3a;
        }

        #toolbar button.danger {
            background: #5a2a2a;
        }

        #toolbar button.danger:hover {
            background: #7a3a3a;
        }

        #toolbar button.active {
            background: #4a4;
        }

        .toolbar-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Offset rack for toolbar */
        .rack {
            margin-top: 48px;
        }

        /* App container - sidebar + rack area */
        .app-container {
            display: flex;
            margin-top: 48px;
            height: calc(100vh - 48px);
        }

        /* Sidebar */
        .sidebar {
            width: 180px;
            min-width: 180px;
            background: linear-gradient(to bottom, #252525, #1a1a1a);
            border-right: 1px solid #444;
            overflow-y: auto;
            padding: 8px 0;
        }

        .sidebar-category {
            padding: 8px 12px 4px;
            font-size: 9px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-module {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .sidebar-module:hover {
            background: #333;
        }

        .sidebar-module-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .sidebar-module-name {
            flex: 1;
            font-size: 11px;
            color: #ccc;
        }

        .sidebar-module-hp {
            font-size: 9px;
            color: #666;
        }

        /* Rack container - holds two rows */
        .rack-container {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 16px;
        }

        .rack-row {
            margin-top: 0;
            min-height: var(--module-height);
            flex-shrink: 0;
        }

        .rack-row.empty {
            border: 2px dashed #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            font-size: 12px;
        }

        .rack-row.drag-over {
            background: rgba(100, 200, 100, 0.1);
            border-color: #4a4;
        }

        /* Module drag and remove states */
        .module {
            position: relative;
            cursor: grab;
        }

        .module:active {
            cursor: grabbing;
        }

        .module.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .module .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: rgba(180, 60, 60, 0.9);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .module:hover .remove-btn {
            opacity: 1;
        }

        .module .remove-btn:hover {
            background: #c44;
        }

        .module.drag-over-left::before,
        .module.drag-over-right::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #4a4;
        }

        .module.drag-over-left::before {
            left: -3px;
        }

        .module.drag-over-right::after {
            right: -3px;
        }

        /* Row HP indicator */
        .row-hp-indicator {
            position: absolute;
            bottom: -20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: #555;
        }
    </style>
</head>
<body>
<div id="toolbar">
    <div class="toolbar-section">
        <button id="startButton">▶ Start</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <span class="toolbar-label">Patches</span>
        <select id="patchSelect">
            <option value="">-- Select --</option>
        </select>
        <button id="loadPatch">Load</button>
        <button id="deletePatch" class="danger">Del</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <input type="text" id="patchName" placeholder="New patch...">
        <button id="savePatch" class="primary">Save</button>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button id="copyPatch">Copy</button>
    </div>
    <div class="toolbar-spacer"></div>
    <div class="toolbar-section">
        <button id="clearCables">Clear Cables</button>
    </div>
</div>

<svg id="cable-svg"></svg>

<div class="app-container">
    <div class="sidebar" id="sidebar">
        <!-- Module categories populated by JS -->
    </div>
    <div class="rack-container" id="rack-container">
        <div class="rack rack-row" id="rack-row-1"></div>
        <div class="rack rack-row" id="rack-row-2"></div>
    </div>
</div>

<script type="module">
    /* =============================================================
     * Import modular definitions
     * =========================================================== */
    import { loadModules, moduleRegistry, DEFAULT_MODULE_ORDER } from './js/index.js';
    import { CABLE_COLORS } from './js/config/constants.js';
    import { FACTORY_PATCHES } from './js/config/factory-patches.js';
    import { adjustColor } from './js/utils/color.js';
    import { createAudioEngine } from './js/audio/engine.js';
    import { createCablePath, getJackCenter } from './js/cables/cable-manager.js';

    /* =============================================================
     * Interactive Patcher System
     * -------------------------------------------------------------
     * Renders modules with knobs and jacks, allows cable patching
     * =========================================================== */

    /* Constants imported from js/config/constants.js */
    let colorIndex = 0;

    /* State */
    let audioCtx = null;
    let engine = null;
    let isRunning = false;
    let modules = {};
    let cables = [];
    let dragState = null;

    /* New state for flexible rack */
    const MAX_HP_PER_ROW = 84;
    let instanceCounters = {};  // Counter per module type for unique IDs
    let row1Modules = [];       // Instance IDs in row 1
    let row2Modules = [];       // Instance IDs in row 2
    let draggedModule = null;   // Currently dragged module ID

    /* Module definitions from the self-contained module system */
    const MODULE_ORDER = DEFAULT_MODULE_ORDER;

    /* Category display order and labels */
    const CATEGORY_ORDER = ['clock', 'modulation', 'quantizer', 'voice', 'effect', 'output', 'other'];
    const CATEGORY_LABELS = {
        'clock': 'Clock & Utility',
        'modulation': 'Modulation',
        'quantizer': 'Quantizer',
        'voice': 'Voices',
        'effect': 'Effects',
        'output': 'Output',
        'other': 'Other'
    };


    /* =============================================================
     * UI Rendering
     * =========================================================== */
    function renderModule(type, id) {
        const def = moduleRegistry.get(type);
        const ui = def.ui || {};
        const el = document.createElement('div');
        el.className = `module module-${def.hp}hp`;
        el.id = `module-${id}`;
        el.style.background = `linear-gradient(to bottom, ${def.color}, ${adjustColor(def.color, -30)})`;

        let html = `<div class="module-label">${def.name}</div><div class="module-content">`;

        /* LEDs */
        if (ui.leds && ui.leds.length > 0) {
            html += '<div class="jack-row">';
            ui.leds.forEach(led => {
                html += `<div class="led green" id="led-${id}-${led}"></div>`;
            });
            html += '</div>';
        }

        /* Knobs - render in a row if more than 2 */
        const knobs = ui.knobs || [];
        if (knobs.length > 2) {
            html += '<div class="jack-row">';
        }
        knobs.forEach(knob => {
            html += `
                <div class="knob-container">
                    <div class="knob" id="knob-${id}-${knob.id}"
                         data-module="${id}" data-param="${knob.param}"
                         data-min="${knob.min}" data-max="${knob.max}"
                         data-value="${knob.default}" data-step="${knob.step || 0}"></div>
                    <div class="knob-label">${knob.label}</div>
                </div>`;
        });
        if (knobs.length > 2) {
            html += '</div>';
        }

        /* Switches - render in a row */
        const switches = ui.switches || [];
        if (switches.length > 0) {
            html += '<div class="jack-row">';
            switches.forEach(sw => {
                html += `
                    <div class="knob-container">
                        <div class="switch ${sw.default ? 'on' : ''}" id="switch-${id}-${sw.id}"
                             data-module="${id}" data-param="${sw.param}"></div>
                        <div class="knob-label">${sw.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Button banks (octave select) */
        const buttons = ui.buttons || [];
        if (buttons.length > 0) {
            buttons.forEach(btnGroup => {
                html += `<div class="section-label">${btnGroup.label}</div><div class="button-bank" data-module="${id}" data-param="${btnGroup.param}">`;
                btnGroup.values.forEach((val, idx) => {
                    const isActive = val === btnGroup.default;
                    html += `<button class="octave-btn${isActive ? ' active' : ''}" data-value="${val}">${val > 0 ? '+' + val : val}</button>`;
                });
                html += '</div>';
            });
        }

        html += '<div class="spacer"></div>';

        /* Outputs */
        const outputs = ui.outputs || [];
        if (outputs.length > 0) {
            html += '<div class="section-label">Out</div><div class="jack-row">';
            outputs.forEach(out => {
                html += `
                    <div class="jack-container">
                        <div class="jack output" id="jack-${id}-${out.id}"
                             data-module="${id}" data-port="${out.port}" data-dir="output" data-type="${out.type}"></div>
                        <div class="jack-label">${out.label}</div>
                    </div>`;
            });
            html += '</div>';
        }

        /* Inputs - group by type for larger modules */
        const inputs = ui.inputs || [];
        if (inputs.length > 0) {
            if (inputs.length > 4) {
                /* Split inputs into groups (CV and triggers) */
                const cvInputs = inputs.filter(i => i.type === 'cv' || i.id.startsWith('cv'));
                const trigInputs = inputs.filter(i => i.type === 'trigger' || i.id.startsWith('trig'));
                const otherInputs = inputs.filter(i =>
                    i.type !== 'cv' && i.type !== 'trigger' &&
                    !i.id.startsWith('cv') && !i.id.startsWith('trig'));

                if (cvInputs.length > 0) {
                    html += '<div class="section-label">CV In</div><div class="jack-row">';
                    cvInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (trigInputs.length > 0) {
                    html += '<div class="section-label">Trig In</div><div class="jack-row">';
                    trigInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
                if (otherInputs.length > 0) {
                    html += '<div class="section-label">In</div><div class="jack-row">';
                    otherInputs.forEach(inp => {
                        html += `
                            <div class="jack-container">
                                <div class="jack input" id="jack-${id}-${inp.id}"
                                     data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                                <div class="jack-label">${inp.label}</div>
                            </div>`;
                    });
                    html += '</div>';
                }
            } else {
                html += '<div class="section-label">In</div><div class="jack-row">';
                inputs.forEach(inp => {
                    html += `
                        <div class="jack-container">
                            <div class="jack input" id="jack-${id}-${inp.id}"
                                 data-module="${id}" data-port="${inp.port}" data-dir="input" data-type="${inp.type}"></div>
                            <div class="jack-label">${inp.label}</div>
                        </div>`;
                });
                html += '</div>';
            }
        }

        html += '</div>';
        el.innerHTML = html;
        return el;
    }

    function updateKnobRotation(knobEl) {
        const min = parseFloat(knobEl.dataset.min);
        const max = parseFloat(knobEl.dataset.max);
        const value = parseFloat(knobEl.dataset.value);
        const rotation = -135 + ((value - min) / (max - min)) * 270;
        knobEl.style.setProperty('--rotation', `${rotation}deg`);
        const indicator = knobEl.querySelector('::after') || knobEl;
        knobEl.style.transform = `rotate(${rotation}deg)`;
    }

    /* =============================================================
     * Sidebar & Module Management
     * =========================================================== */

    function populateSidebar() {
        const sidebar = document.getElementById('sidebar');
        sidebar.innerHTML = '';

        // Get all registered categories
        const registeredCategories = moduleRegistry.getCategories();

        // Build category -> modules map
        const categoryModules = {};
        CATEGORY_ORDER.forEach(cat => {
            categoryModules[cat] = [];
        });

        // Populate with modules from registry
        registeredCategories.forEach(cat => {
            const targetCat = CATEGORY_ORDER.includes(cat) ? cat : 'other';
            const mods = moduleRegistry.getByCategory(cat);
            categoryModules[targetCat].push(...mods);
        });

        // Render each category
        CATEGORY_ORDER.forEach(cat => {
            const mods = categoryModules[cat];
            if (mods.length === 0) return;

            const categoryEl = document.createElement('div');
            categoryEl.className = 'sidebar-category';
            categoryEl.textContent = CATEGORY_LABELS[cat] || cat;
            sidebar.appendChild(categoryEl);

            mods.forEach(def => {
                const modEl = document.createElement('div');
                modEl.className = 'sidebar-module';
                modEl.dataset.moduleType = def.id;
                modEl.innerHTML = `
                    <div class="sidebar-module-color" style="background: ${def.color}"></div>
                    <div class="sidebar-module-name">${def.name}</div>
                    <div class="sidebar-module-hp">${def.hp}hp</div>
                `;
                modEl.addEventListener('click', () => addModuleToRack(def.id));
                sidebar.appendChild(modEl);
            });
        });
    }

    function getRowHP(rowModules) {
        return rowModules.reduce((sum, id) => {
            const mod = modules[id];
            return sum + (mod ? mod.def.hp : 0);
        }, 0);
    }

    function generateInstanceId(moduleType) {
        if (!instanceCounters[moduleType]) {
            instanceCounters[moduleType] = 0;
        }
        instanceCounters[moduleType]++;
        return `${moduleType}_${instanceCounters[moduleType]}`;
    }

    function addModuleToRack(moduleType, targetRow = null, targetPosition = null, forceInstanceId = null) {
        const def = moduleRegistry.get(moduleType);
        if (!def) {
            console.warn(`Module type "${moduleType}" not found`);
            return null;
        }

        const hp = def.hp;
        const row1HP = getRowHP(row1Modules);
        const row2HP = getRowHP(row2Modules);

        // Determine which row to add to
        let row, rowModules, rowEl;
        if (targetRow === 1 || (targetRow === null && row1HP + hp <= MAX_HP_PER_ROW)) {
            row = 1;
            rowModules = row1Modules;
            rowEl = document.getElementById('rack-row-1');
        } else if (targetRow === 2 || (targetRow === null && row2HP + hp <= MAX_HP_PER_ROW)) {
            row = 2;
            rowModules = row2Modules;
            rowEl = document.getElementById('rack-row-2');
        } else {
            console.warn('Both rows are full');
            return null;
        }

        // Check if it fits
        const currentHP = getRowHP(rowModules);
        if (currentHP + hp > MAX_HP_PER_ROW) {
            console.warn(`Row ${row} is full`);
            return null;
        }

        // Use provided instance ID or generate a new one
        const instanceId = forceInstanceId || generateInstanceId(moduleType);

        // Create module element
        const el = renderModule(moduleType, instanceId);
        el.draggable = true;
        el.dataset.instanceId = instanceId;
        el.dataset.row = row;

        // Add remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerHTML = '×';
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeModuleFromRack(instanceId);
        });
        el.appendChild(removeBtn);

        // Add drag handlers
        el.addEventListener('dragstart', handleModuleDragStart);
        el.addEventListener('dragend', handleModuleDragEnd);
        el.addEventListener('dragover', handleModuleDragOver);
        el.addEventListener('dragleave', handleModuleDragLeave);
        el.addEventListener('drop', handleModuleDrop);

        // Create DSP instance if audio is running
        let instance = null;
        if (audioCtx) {
            instance = def.createDSP({
                sampleRate: audioCtx.sampleRate,
                bufferSize: 512,
                audioCtx: audioCtx
            });
        }

        // Store in modules map
        modules[instanceId] = { def, el, instance, type: moduleType, row };

        // Add to row
        if (targetPosition !== null && targetPosition < rowModules.length) {
            const beforeEl = document.getElementById(`module-${rowModules[targetPosition]}`);
            rowEl.insertBefore(el, beforeEl);
            rowModules.splice(targetPosition, 0, instanceId);
        } else {
            rowEl.appendChild(el);
            rowModules.push(instanceId);
        }

        // Update row empty state
        rowEl.classList.remove('empty');

        // Initialize knob rotations
        el.querySelectorAll('.knob').forEach(updateKnobRotation);

        // Update engine if running
        updateEngineModules();

        return instanceId;
    }

    function removeModuleFromRack(instanceId) {
        const mod = modules[instanceId];
        if (!mod) return;

        // Remove connected cables
        const connectedCables = cables.filter(c =>
            c.fromModule === instanceId || c.toModule === instanceId
        );
        connectedCables.forEach(removeCable);

        // Remove from DOM
        mod.el.remove();

        // Remove from row array
        const row1Idx = row1Modules.indexOf(instanceId);
        if (row1Idx >= 0) {
            row1Modules.splice(row1Idx, 1);
            if (row1Modules.length === 0) {
                document.getElementById('rack-row-1').classList.add('empty');
            }
        }
        const row2Idx = row2Modules.indexOf(instanceId);
        if (row2Idx >= 0) {
            row2Modules.splice(row2Idx, 1);
            if (row2Modules.length === 0) {
                document.getElementById('rack-row-2').classList.add('empty');
            }
        }

        // Remove from modules map
        delete modules[instanceId];

        // Update engine
        updateEngineModules();
    }

    function updateEngineModules() {
        if (engine) {
            engine.setModules(modules);
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }
    }

    /* =============================================================
     * Module Drag and Drop
     * =========================================================== */

    function handleModuleDragStart(e) {
        const moduleEl = e.target.closest('.module');
        if (!moduleEl) return;

        draggedModule = moduleEl.dataset.instanceId;
        moduleEl.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedModule);
    }

    function handleModuleDragEnd(e) {
        const moduleEl = e.target.closest('.module');
        if (moduleEl) {
            moduleEl.classList.remove('dragging');
        }
        draggedModule = null;

        // Clean up all drag-over states
        document.querySelectorAll('.module').forEach(el => {
            el.classList.remove('drag-over-left', 'drag-over-right');
        });
        document.querySelectorAll('.rack-row').forEach(el => {
            el.classList.remove('drag-over');
        });
    }

    function handleModuleDragOver(e) {
        e.preventDefault();
        if (!draggedModule) return;

        const moduleEl = e.target.closest('.module');
        if (!moduleEl || moduleEl.dataset.instanceId === draggedModule) return;

        // Determine if dropping left or right of this module
        const rect = moduleEl.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;

        moduleEl.classList.remove('drag-over-left', 'drag-over-right');
        if (e.clientX < midX) {
            moduleEl.classList.add('drag-over-left');
        } else {
            moduleEl.classList.add('drag-over-right');
        }
    }

    function handleModuleDragLeave(e) {
        const moduleEl = e.target.closest('.module');
        if (moduleEl) {
            moduleEl.classList.remove('drag-over-left', 'drag-over-right');
        }
    }

    function handleModuleDrop(e) {
        e.preventDefault();
        if (!draggedModule) return;

        const targetModuleEl = e.target.closest('.module');
        if (!targetModuleEl) return;

        const targetId = targetModuleEl.dataset.instanceId;
        if (targetId === draggedModule) return;

        const draggedMod = modules[draggedModule];
        const targetMod = modules[targetId];
        if (!draggedMod || !targetMod) return;

        // Determine drop position (before or after target)
        const rect = targetModuleEl.getBoundingClientRect();
        const dropAfter = e.clientX >= rect.left + rect.width / 2;

        // Remove from current position
        const fromRow = draggedMod.row;
        const fromRowModules = fromRow === 1 ? row1Modules : row2Modules;
        const fromIdx = fromRowModules.indexOf(draggedModule);
        if (fromIdx >= 0) {
            fromRowModules.splice(fromIdx, 1);
        }

        // Determine target row and position
        const toRow = targetMod.row;
        const toRowModules = toRow === 1 ? row1Modules : row2Modules;
        let toIdx = toRowModules.indexOf(targetId);
        if (dropAfter) toIdx++;

        // Check if it fits in target row (if changing rows)
        if (fromRow !== toRow) {
            const toRowHP = getRowHP(toRowModules);
            if (toRowHP + draggedMod.def.hp > MAX_HP_PER_ROW) {
                // Revert - doesn't fit
                fromRowModules.splice(fromIdx, 0, draggedModule);
                return;
            }
        }

        // Insert at new position
        toRowModules.splice(toIdx, 0, draggedModule);
        draggedMod.row = toRow;
        draggedMod.el.dataset.row = toRow;

        // Update DOM
        const toRowEl = document.getElementById(`rack-row-${toRow}`);
        const fromRowEl = document.getElementById(`rack-row-${fromRow}`);

        if (toIdx >= toRowModules.length - 1) {
            toRowEl.appendChild(draggedMod.el);
        } else {
            const beforeEl = document.getElementById(`module-${toRowModules[toIdx + 1]}`);
            if (beforeEl) {
                toRowEl.insertBefore(draggedMod.el, beforeEl);
            } else {
                toRowEl.appendChild(draggedMod.el);
            }
        }

        // Update empty states
        if (fromRowModules.length === 0) {
            fromRowEl.classList.add('empty');
        }
        toRowEl.classList.remove('empty');

        // Clean up drag states
        targetModuleEl.classList.remove('drag-over-left', 'drag-over-right');

        // Redraw cables
        cables.forEach(renderCable);
    }

    function handleRowDragOver(e) {
        e.preventDefault();
        if (!draggedModule) return;

        const rowEl = e.target.closest('.rack-row');
        if (rowEl && rowEl.children.length === 0) {
            rowEl.classList.add('drag-over');
        }
    }

    function handleRowDragLeave(e) {
        const rowEl = e.target.closest('.rack-row');
        if (rowEl) {
            rowEl.classList.remove('drag-over');
        }
    }

    function handleRowDrop(e) {
        e.preventDefault();
        if (!draggedModule) return;

        const rowEl = e.target.closest('.rack-row');
        if (!rowEl) return;

        const targetRow = rowEl.id === 'rack-row-1' ? 1 : 2;
        const draggedMod = modules[draggedModule];
        if (!draggedMod) return;

        // Check if dropping on empty row
        const targetRowModules = targetRow === 1 ? row1Modules : row2Modules;

        // Only handle if row is empty or dropping at end
        if (targetRowModules.length > 0) return;

        // Check if it fits
        if (draggedMod.def.hp > MAX_HP_PER_ROW) return;

        // Remove from current position
        const fromRow = draggedMod.row;
        const fromRowModules = fromRow === 1 ? row1Modules : row2Modules;
        const fromIdx = fromRowModules.indexOf(draggedModule);
        if (fromIdx >= 0) {
            fromRowModules.splice(fromIdx, 1);
        }

        // Add to new row
        targetRowModules.push(draggedModule);
        draggedMod.row = targetRow;
        draggedMod.el.dataset.row = targetRow;

        // Update DOM
        rowEl.appendChild(draggedMod.el);

        // Update empty states
        const fromRowEl = document.getElementById(`rack-row-${fromRow}`);
        if (fromRowModules.length === 0) {
            fromRowEl.classList.add('empty');
        }
        rowEl.classList.remove('drag-over', 'empty');

        // Redraw cables
        cables.forEach(renderCable);
    }

    /* =============================================================
     * Cable System
     * =========================================================== */
    const svgNS = 'http://www.w3.org/2000/svg';
    const cableSvg = document.getElementById('cable-svg');

    function renderCable(cable) {
        const from = getJackCenter(cable.fromEl);
        const to = getJackCenter(cable.toEl);
        cable.pathEl.setAttribute('d', createCablePath(from.x, from.y, to.x, to.y));
    }

    function addCable(fromJack, toJack, color = null) {
        const path = document.createElementNS(svgNS, 'path');
        path.classList.add('cable');
        /* Use provided color or get next color from palette */
        path.style.stroke = color || CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
        cableSvg.appendChild(path);

        const cable = {
            fromEl: fromJack,
            toEl: toJack,
            pathEl: path,
            fromModule: fromJack.dataset.module,
            fromPort: fromJack.dataset.port,
            toModule: toJack.dataset.module,
            toPort: toJack.dataset.port,
            type: fromJack.dataset.type
        };

        cables.push(cable);
        fromJack.classList.add('connected');
        toJack.classList.add('connected');
        renderCable(cable);

        /* Update engine with new cable state */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }

        return cable;
    }

    function removeCable(cable) {
        cable.pathEl.remove();
        cable.fromEl.classList.remove('connected');
        cable.toEl.classList.remove('connected');
        cables = cables.filter(c => c !== cable);

        /* Update engine with new cable state - handles audio input clearing */
        if (engine) {
            engine.setCables(cables.map(c => ({
                fromModule: c.fromModule,
                fromPort: c.fromPort,
                toModule: c.toModule,
                toPort: c.toPort
            })));
        }
    }

    function clearAllCables() {
        cables.forEach(c => {
            c.pathEl.remove();
            c.fromEl.classList.remove('connected');
            c.toEl.classList.remove('connected');
        });
        cables = [];

        /* Update engine with empty cables - handles audio input clearing */
        if (engine) {
            engine.setCables([]);
        }
    }

    /* Preview cable while dragging */
    let previewPath = null;

    function startDrag(jackEl, e) {
        /* Check if this jack has an existing cable connected */
        const existingCable = cables.find(c => c.fromEl === jackEl || c.toEl === jackEl);

        if (existingCable) {
            /* Detach the cable from this jack, drag from the other end */
            const isFromEnd = existingCable.fromEl === jackEl;
            const anchorJack = isFromEnd ? existingCable.toEl : existingCable.fromEl;
            const cableColor = existingCable.pathEl.style.stroke;

            /* Remove the existing cable */
            removeCable(existingCable);

            /* Start dragging from the anchor (the other end) */
            dragState = {
                startJack: anchorJack,
                startDir: anchorJack.dataset.dir,
                reconnecting: true
            };

            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = cableColor;
            cableSvg.appendChild(previewPath);
        } else {
            /* No existing cable - start new connection */
            dragState = {
                startJack: jackEl,
                startDir: jackEl.dataset.dir,
                reconnecting: false
            };
            previewPath = document.createElementNS(svgNS, 'path');
            previewPath.classList.add('cable', 'cable-preview');
            previewPath.style.stroke = CABLE_COLORS[colorIndex++ % CABLE_COLORS.length];
            cableSvg.appendChild(previewPath);
        }
        updatePreview(e);
    }

    function updatePreview(e) {
        if (!dragState || !previewPath) return;
        const start = getJackCenter(dragState.startJack);
        const end = {x: e.clientX, y: e.clientY};
        previewPath.setAttribute('d', createCablePath(start.x, start.y, end.x, end.y));
    }

    function endDrag(targetJack) {
        if (!dragState) return;

        const cableColor = previewPath ? previewPath.style.stroke : CABLE_COLORS[colorIndex % CABLE_COLORS.length];

        if (previewPath) {
            previewPath.remove();
            previewPath = null;
        }

        let connected = false;

        if (targetJack && targetJack !== dragState.startJack) {
            const startDir = dragState.startDir;
            const endDir = targetJack.dataset.dir;

            /* Must connect output to input (different directions) */
            if (startDir !== endDir) {
                const fromJack = startDir === 'output' ? dragState.startJack : targetJack;
                const toJack = startDir === 'input' ? dragState.startJack : targetJack;

                /* Remove existing cable to this input */
                const existing = cables.find(c => c.toEl === toJack);
                if (existing) removeCable(existing);

                addCable(fromJack, toJack, cableColor);
                connected = true;
            }
        }

        /* If reconnecting and dropped on invalid target, cable is removed (already done in startDrag) */
        /* If new cable and dropped on invalid target, nothing happens */

        dragState = null;
    }

    /* =============================================================
     * Knob Interaction
     * =========================================================== */
    let knobDrag = null;

    function startKnobDrag(knobEl, e) {
        knobDrag = {
            knob: knobEl,
            startY: e.clientY,
            startValue: parseFloat(knobEl.dataset.value)
        };
    }

    function updateKnobDrag(e) {
        if (!knobDrag) return;
        const knob = knobDrag.knob;
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const step = parseFloat(knob.dataset.step) || 0;
        const range = max - min;
        const dy = knobDrag.startY - e.clientY;
        let newValue = knobDrag.startValue + (dy / 150) * range;

        if (step > 0) {
            newValue = Math.round(newValue / step) * step;
        }
        newValue = Math.max(min, Math.min(max, newValue));

        knob.dataset.value = newValue;
        updateKnobRotation(knob);

        /* Update module param */
        const moduleId = knob.dataset.module;
        const param = knob.dataset.param;
        if (modules[moduleId] && modules[moduleId].instance) {
            modules[moduleId].instance.params[param] = newValue;
        }
    }

    function endKnobDrag() {
        knobDrag = null;
    }

    /* =============================================================
     * Patch Bank System
     * -------------------------------------------------------------
     * Save and load patches to/from localStorage
     * =========================================================== */
    const PATCH_STORAGE_KEY = 'eurorack-patches';


    function getPatchList() {
        try {
            const data = localStorage.getItem(PATCH_STORAGE_KEY);
            const userPatches = data ? JSON.parse(data) : {};
            /* Merge factory patches with user patches (user patches take precedence) */
            return { ...FACTORY_PATCHES, ...userPatches };
        } catch (e) {
            console.error('Error loading patches:', e);
            return { ...FACTORY_PATCHES };
        }
    }

    function savePatchList(patches) {
        try {
            localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(patches));
        } catch (e) {
            console.error('Error saving patches:', e);
        }
    }

    function serializeCurrentState() {
        const state = {
            modules: [],   // Module layout: [{type, instanceId, row}]
            knobs: {},
            switches: {},
            buttons: {},
            cables: []
        };

        /* Serialize module layout */
        row1Modules.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                state.modules.push({ type: mod.type, instanceId, row: 1 });
            }
        });
        row2Modules.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                state.modules.push({ type: mod.type, instanceId, row: 2 });
            }
        });

        /* Serialize all knob values */
        document.querySelectorAll('.knob').forEach(knob => {
            const moduleId = knob.dataset.module;
            const param = knob.dataset.param;
            const value = parseFloat(knob.dataset.value);
            if (!state.knobs[moduleId]) state.knobs[moduleId] = {};
            state.knobs[moduleId][param] = value;
        });

        /* Serialize all switch states */
        document.querySelectorAll('.switch').forEach(sw => {
            const moduleId = sw.dataset.module;
            const param = sw.dataset.param;
            const isOn = sw.classList.contains('on');
            if (!state.switches[moduleId]) state.switches[moduleId] = {};
            state.switches[moduleId][param] = isOn;
        });

        /* Serialize all button bank states */
        document.querySelectorAll('.button-bank').forEach(bank => {
            const moduleId = bank.dataset.module;
            const param = bank.dataset.param;
            const activeBtn = bank.querySelector('.octave-btn.active');
            const value = activeBtn ? parseInt(activeBtn.dataset.value) : 0;
            if (!state.buttons[moduleId]) state.buttons[moduleId] = {};
            state.buttons[moduleId][param] = value;
        });

        /* Serialize cable connections */
        cables.forEach(cable => {
            state.cables.push({
                fromModule: cable.fromModule,
                fromPort: cable.fromPort,
                toModule: cable.toModule,
                toPort: cable.toPort
            });
        });

        return state;
    }

    function clearRack() {
        /* Remove all modules from rack */
        const allModuleIds = [...row1Modules, ...row2Modules];
        allModuleIds.forEach(instanceId => {
            const mod = modules[instanceId];
            if (mod) {
                mod.el.remove();
                delete modules[instanceId];
            }
        });
        row1Modules.length = 0;
        row2Modules.length = 0;
        instanceCounters = {};

        /* Mark rows as empty */
        document.getElementById('rack-row-1').classList.add('empty');
        document.getElementById('rack-row-2').classList.add('empty');
    }

    function applyPatchState(state) {
        /* Clear existing cables */
        clearAllCables();

        /* Build ID mapping for old-style patches */
        const idMapping = {};

        /* Handle module layout - new format includes modules array */
        if (state.modules && state.modules.length > 0) {
            /* Clear existing rack and rebuild from saved layout */
            clearRack();

            state.modules.forEach(modInfo => {
                const { type, instanceId, row } = modInfo;
                /* Pass the saved instanceId to preserve exact IDs */
                addModuleToRack(type, row, null, instanceId);
            });
        } else {
            /* Legacy patch format - use MODULE_ORDER if no layout and rack is empty */
            if (row1Modules.length === 0 && row2Modules.length === 0) {
                MODULE_ORDER.forEach(type => {
                    const newId = addModuleToRack(type);
                    idMapping[type] = newId;
                });
            } else {
                /* Keep current modules, map old type-based IDs to current instance IDs */
                Object.keys(modules).forEach(instanceId => {
                    const mod = modules[instanceId];
                    idMapping[mod.type] = instanceId;
                });
            }
        }

        /* Helper to resolve module ID (handles both old and new formats) */
        const resolveModuleId = (savedId) => idMapping[savedId] || savedId;

        /* Apply knob values */
        if (state.knobs) {
            Object.entries(state.knobs).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, value]) => {
                    const knob = document.querySelector(`.knob[data-module="${moduleId}"][data-param="${param}"]`);
                    if (knob) {
                        knob.dataset.value = value;
                        updateKnobRotation(knob);
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    }
                });
            });
        }

        /* Apply switch states */
        if (state.switches) {
            Object.entries(state.switches).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, isOn]) => {
                    const sw = document.querySelector(`.switch[data-module="${moduleId}"][data-param="${param}"]`);
                    if (sw) {
                        sw.classList.toggle('on', isOn);
                        if (modules[moduleId]?.instance) {
                            if (param.includes('[')) {
                                const match = param.match(/(\w+)\[(\d+)\]/);
                                if (match) {
                                    modules[moduleId].instance.params[match[1]][parseInt(match[2])] = isOn;
                                }
                            } else {
                                modules[moduleId].instance.params[param] = isOn ? 1 : 0;
                            }
                        }
                    }
                });
            });
        }

        /* Apply button bank states */
        if (state.buttons) {
            Object.entries(state.buttons).forEach(([savedId, params]) => {
                const moduleId = resolveModuleId(savedId);
                Object.entries(params).forEach(([param, value]) => {
                    const bank = document.querySelector(`.button-bank[data-module="${moduleId}"][data-param="${param}"]`);
                    if (bank) {
                        bank.querySelectorAll('.octave-btn').forEach(btn => {
                            btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
                        });
                        if (modules[moduleId]?.instance) {
                            modules[moduleId].instance.params[param] = value;
                        }
                    }
                });
            });
        }

        /* Apply cable connections */
        if (state.cables) {
            state.cables.forEach(conn => {
                const fromModule = resolveModuleId(conn.fromModule);
                const toModule = resolveModuleId(conn.toModule);
                /* Find jacks by module, port, and direction (output→input) */
                const fromJack = document.querySelector(`.jack.output[data-module="${fromModule}"][data-port="${conn.fromPort}"]`);
                const toJack = document.querySelector(`.jack.input[data-module="${toModule}"][data-port="${conn.toPort}"]`);
                if (fromJack && toJack) {
                    addCable(fromJack, toJack);
                }
            });
        }
    }

    function savePatch(name) {
        if (!name || !name.trim()) {
            alert('Please enter a patch name');
            return false;
        }
        name = name.trim();

        const patches = getPatchList();
        patches[name] = {
            name: name,
            created: new Date().toISOString(),
            state: serializeCurrentState()
        };

        savePatchList(patches);
        updatePatchSelect();
        return true;
    }

    function loadPatch(name) {
        const patches = getPatchList();
        if (!patches[name]) {
            alert('Patch not found');
            return false;
        }

        applyPatchState(patches[name].state);
        return true;
    }

    function deletePatch(name) {
        if (!name) return false;

        /* Cannot delete factory patches */
        if (FACTORY_PATCHES[name]) {
            alert('Cannot delete factory patches');
            return false;
        }

        const patches = getPatchList();
        if (!patches[name]) return false;

        if (!confirm(`Delete patch "${name}"?`)) return false;

        /* Only delete from user patches in localStorage */
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        delete userPatches[name];
        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(userPatches));
        updatePatchSelect();
        return true;
    }

    function copyPatchToClipboard() {
        const state = serializeCurrentState();
        const json = JSON.stringify(state, null, 4);
        navigator.clipboard.writeText(json).then(() => {
            const btn = document.getElementById('copyPatch');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = originalText, 1500);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    }

    function updatePatchSelect() {
        const select = document.getElementById('patchSelect');
        const patches = getPatchList();

        /* Clear existing options except the first placeholder */
        while (select.options.length > 1) {
            select.remove(1);
        }

        /* Separate factory and user patches */
        const factoryNames = Object.keys(FACTORY_PATCHES).sort();
        const userPatches = JSON.parse(localStorage.getItem(PATCH_STORAGE_KEY) || '{}');
        const userNames = Object.keys(userPatches).sort();

        /* Add factory patches group */
        if (factoryNames.length > 0) {
            const factoryGroup = document.createElement('optgroup');
            factoryGroup.label = 'Factory Patches';
            factoryNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                factoryGroup.appendChild(option);
            });
            select.appendChild(factoryGroup);
        }

        /* Add user patches group */
        if (userNames.length > 0) {
            const userGroup = document.createElement('optgroup');
            userGroup.label = 'My Patches';
            userNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                userGroup.appendChild(option);
            });
            select.appendChild(userGroup);
        }
    }

    function initPatchBank() {
        /* Update patch list dropdown */
        updatePatchSelect();

        /* Save button */
        document.getElementById('savePatch').addEventListener('click', () => {
            const nameInput = document.getElementById('patchName');
            if (savePatch(nameInput.value)) {
                /* Select the newly saved patch */
                document.getElementById('patchSelect').value = nameInput.value.trim();
                nameInput.value = '';
            }
        });

        /* Load button */
        document.getElementById('loadPatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });

        /* Delete button */
        document.getElementById('deletePatch').addEventListener('click', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                deletePatch(select.value);
                select.value = '';
            }
        });

        /* Allow Enter key to save */
        document.getElementById('patchName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('savePatch').click();
            }
        });

        /* Double-click on select to load */
        document.getElementById('patchSelect').addEventListener('dblclick', () => {
            const select = document.getElementById('patchSelect');
            if (select.value) {
                loadPatch(select.value);
            }
        });
    }

    /* =============================================================
     * Initialization
     * =========================================================== */
    async function init() {
        /* Load all module definitions into registry */
        await loadModules();

        /* Populate sidebar with available modules */
        populateSidebar();

        /* Set up rack rows */
        const row1 = document.getElementById('rack-row-1');
        const row2 = document.getElementById('rack-row-2');

        /* Mark rows as empty initially */
        row1.classList.add('empty');
        row2.classList.add('empty');

        /* Set up drag handlers for empty row drops */
        [row1, row2].forEach(rowEl => {
            rowEl.addEventListener('dragover', handleRowDragOver);
            rowEl.addEventListener('dragleave', handleRowDragLeave);
            rowEl.addEventListener('drop', handleRowDrop);
        });

        /* Event listeners */
        document.addEventListener('mousedown', e => {
            const jack = e.target.closest('.jack');
            const knob = e.target.closest('.knob');
            const sw = e.target.closest('.switch');
            const octBtn = e.target.closest('.octave-btn');

            if (jack) {
                e.preventDefault();
                /* Right-click to remove cables */
                if (e.button === 2) {
                    const cable = cables.find(c => c.fromEl === jack || c.toEl === jack);
                    if (cable) removeCable(cable);
                } else {
                    startDrag(jack, e);
                }
            } else if (knob) {
                e.preventDefault();
                startKnobDrag(knob, e);
            } else if (sw) {
                e.preventDefault();
                sw.classList.toggle('on');
                const moduleId = sw.dataset.module;
                const param = sw.dataset.param;
                if (modules[moduleId]?.instance) {
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        modules[moduleId].instance.params[match[1]][parseInt(match[2])] = sw.classList.contains('on');
                    } else {
                        modules[moduleId].instance.params[param] = sw.classList.contains('on') ? 1 : 0;
                    }
                }
            } else if (octBtn) {
                e.preventDefault();
                const bank = octBtn.closest('.button-bank');
                const moduleId = bank.dataset.module;
                const param = bank.dataset.param;
                const value = parseInt(octBtn.dataset.value);
                /* Toggle active state */
                bank.querySelectorAll('.octave-btn').forEach(b => b.classList.remove('active'));
                octBtn.classList.add('active');
                /* Update module param */
                if (modules[moduleId]?.instance) {
                    modules[moduleId].instance.params[param] = value;
                }
            }
        });

        document.addEventListener('mousemove', e => {
            if (dragState) updatePreview(e);
            if (knobDrag) updateKnobDrag(e);
        });

        document.addEventListener('mouseup', e => {
            if (dragState) {
                const jack = e.target.closest('.jack');
                endDrag(jack);
            }
            if (knobDrag) endKnobDrag();
        });

        document.addEventListener('contextmenu', e => {
            if (e.target.closest('.jack')) e.preventDefault();
        });

        /* Redraw cables on resize */
        window.addEventListener('resize', () => cables.forEach(renderCable));

        /* Control buttons */
        document.getElementById('startButton').addEventListener('click', toggleAudio);
        document.getElementById('clearCables').addEventListener('click', clearAllCables);
        document.getElementById('copyPatch').addEventListener('click', copyPatchToClipboard);

        /* Initialize patch bank */
        initPatchBank();
    }

    function updateLeds(ledStates) {
        Object.entries(ledStates).forEach(([moduleId, leds]) => {
            Object.entries(leds).forEach(([ledId, value]) => {
                const el = document.getElementById(`led-${moduleId}-${ledId}`);
                if (el) {
                    el.classList.toggle('active', value > 0.1);
                }
            });
        });
    }

    function toggleAudio() {
        const btn = document.getElementById('startButton');

        if (isRunning) {
            isRunning = false;
            btn.textContent = '▶ Start';
            btn.classList.remove('active');

            /* Stop the engine */
            if (engine) {
                engine.stop();
                engine = null;
            }

            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            /* Clear instances */
            Object.keys(modules).forEach(id => modules[id].instance = null);
        } else {
            /* Create audio context and module instances */
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            Object.keys(modules).forEach(id => {
                /* Create DSP instance using new module system */
                modules[id].instance = modules[id].def.createDSP({
                    sampleRate: audioCtx.sampleRate,
                    bufferSize: 512,
                    audioCtx: audioCtx
                });
                /* Apply current knob values */
                document.querySelectorAll(`.knob[data-module="${id}"]`).forEach(knob => {
                    const param = knob.dataset.param;
                    const value = parseFloat(knob.dataset.value);
                    modules[id].instance.params[param] = value;
                });
                /* Apply current switch values */
                document.querySelectorAll(`.switch[data-module="${id}"]`).forEach(sw => {
                    const param = sw.dataset.param;
                    const isOn = sw.classList.contains('on');
                    if (param.includes('[')) {
                        const match = param.match(/(\w+)\[(\d+)\]/);
                        modules[id].instance.params[match[1]][parseInt(match[2])] = isOn;
                    } else {
                        modules[id].instance.params[param] = isOn ? 1 : 0;
                    }
                });
                /* Apply current button bank values */
                document.querySelectorAll(`.button-bank[data-module="${id}"]`).forEach(bank => {
                    const param = bank.dataset.param;
                    const activeBtn = bank.querySelector('.octave-btn.active');
                    if (activeBtn) {
                        modules[id].instance.params[param] = parseInt(activeBtn.dataset.value);
                    }
                });
            });

            /* Create engine with modules and cables */
            engine = createAudioEngine({
                modules,
                cables: cables.map(c => ({
                    fromModule: c.fromModule,
                    fromPort: c.fromPort,
                    toModule: c.toModule,
                    toPort: c.toPort
                })),
                audioCtx,
                onLedUpdate: updateLeds
            });

            isRunning = true;
            btn.textContent = '⏹ Stop';
            btn.classList.add('active');
            engine.start();
        }
    }

    /* Start when DOM ready */
    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
